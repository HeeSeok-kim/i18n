---
id: mobile
title: Мобільні команди
---

# Вступ до власних та розширених мобільних команд у WebdriverIO

Тестування мобільних додатків та мобільних веб-додатків має свої власні виклики, особливо коли йдеться про платформові відмінності між Android та iOS. Хоча Appium надає гнучкість для роботи з цими відмінностями, часто доводиться глибоко занурюватися в складну документацію, залежну від платформи ([Android](https://github.com/appium/appium-uiautomator2-driver/blob/master/docs/android-mobile-gestures.md), [iOS](https://appium.github.io/appium-xcuitest-driver/latest/reference/execute-methods/)) та команди. Це може зробити написання тестових скриптів більш трудомістким, схильним до помилок та складним у обслуговуванні.

Щоб спростити процес, WebdriverIO представляє **власні та розширені мобільні команди**, спеціально розроблені для тестування мобільних веб та нативних додатків. Ці команди абстрагують складності базових API Appium, дозволяючи писати лаконічні, інтуїтивно зрозумілі та незалежні від платформи тестові скрипти. Зосереджуючись на простоті використання, ми прагнемо зменшити додаткове навантаження під час розробки скриптів Appium та дати вам можливість автоматизувати мобільні додатки без зусиль.

<LiteYouTubeEmbed
    id="tN0LmKgWjPw"
    title="WebdriverIO Tutorials - Enhanced Mobile Commands"
/>

## Чому власні мобільні команди?

### 1. **Спрощення складних API**
Деякі команди Appium, такі як жести або взаємодія з елементами, мають багатослівний і складний синтаксис. Наприклад, виконання дії довгого натискання з нативним API Appium вимагає ручного створення ланцюга `action`:

```ts
const element = $('~Contacts')

await browser
    .action( 'pointer', { parameters: { pointerType: 'touch' } })
    .move({ origin: element })
    .down()
    .pause(1500)
    .up()
    .perform()
```

З власними командами WebdriverIO, та ж сама дія може бути виконана одним виразним рядком коду:

```ts
await $('~Contacts').longPress();
```

Це кардинально зменшує шаблонний код, роблячи ваші скрипти чистішими і зрозумілішими.

### 2. **Кросплатформна абстракція**
Мобільні додатки часто вимагають обробки, специфічної для платформи. Наприклад, прокрутка в нативних додатках суттєво відрізняється між [Android](https://github.com/appium/appium-uiautomator2-driver/blob/master/docs/android-mobile-gestures.md#mobile-scrollgesture) та [iOS](https://appium.github.io/appium-xcuitest-driver/latest/reference/execute-methods/#mobile-scroll). WebdriverIO долає цей розрив, надаючи уніфіковані команди, такі як `scrollIntoView()`, які плавно працюють на різних платформах, незалежно від базової реалізації.

```ts
await $('~element').scrollIntoView();
```

Ця абстракція забезпечує портативність ваших тестів і не вимагає постійного розгалуження або умовної логіки для врахування відмінностей ОС.

### 3. **Підвищена продуктивність**
Зменшуючи необхідність розуміти та впроваджувати низькорівневі команди Appium, мобільні команди WebdriverIO дозволяють зосередитись на тестуванні функціональності вашого додатка, а не боротися з особливостями конкретної платформи. Це особливо корисно для команд з обмеженим досвідом у мобільній автоматизації або тих, хто прагне прискорити цикл розробки.

### 4. **Узгодженість та підтримуваність**
Власні команди забезпечують однорідність вашим тестовим скриптам. Замість різноманітних реалізацій для подібних дій, ваша команда може покладатися на стандартизовані, повторно використовувані команди. Це не тільки робить кодову базу більш підтримуваною, а й знижує бар'єр для входження нових членів команди.

## Чому розширювати певні мобільні команди?

### 1. Додавання гнучкості
Певні мобільні команди розширені, щоб надати додаткові опції та параметри, які недоступні в стандартних API Appium. Наприклад, WebdriverIO додає логіку повторних спроб, тайм-аути та можливість фільтрувати веб-представлення за певними критеріями, надаючи більший контроль у складних сценаріях.

```ts
// Приклад: Налаштування інтервалів повторних спроб та тайм-аутів для виявлення веб-представлення
await driver.getContexts({
  returnDetailedContexts: true,
  androidWebviewConnectionRetryTime: 1000, // Повторна спроба кожну секунду
  androidWebviewConnectTimeout: 10000,    // Тайм-аут після 10 секунд
});
```

Ці опції допомагають адаптувати скрипти автоматизації до динамічної поведінки додатка без додаткового шаблонного коду.

### 2. Покращення зручності використання
Розширені команди абстрагують складності та повторювані шаблони, знайдені в нативних API. Вони дозволяють виконувати більше дій з меншою кількістю рядків коду, зменшуючи криву навчання для нових користувачів і роблячи скрипти простішими для читання та обслуговування.

```ts
// Приклад: Розширена команда для перемикання контексту за заголовком
await driver.switchContext({
  title: 'My Webview Title',
});
```

Порівняно з методами Appium за замовчуванням, розширені команди усувають потребу в додаткових кроках, таких як ручне отримання доступних контекстів і фільтрування через них.

### 3. Стандартизація поведінки
WebdriverIO забезпечує, що розширені команди поводяться послідовно на різних платформах, таких як Android та iOS. Ця крос-платформна абстракція мінімізує необхідність умовного розгалуження логіки на основі операційної системи, що призводить до більш підтримуваних тестових скриптів.

```ts
// Приклад: Уніфікована команда прокрутки для обох платформ
await $('~element').scrollIntoView();
```

Ця стандартизація спрощує кодові бази, особливо для команд, що автоматизують тести на кількох платформах.

### 4. Підвищення надійності
Завдяки включенню механізмів повторних спроб, розумних значень за замовчуванням та детальних повідомлень про помилки, розширені команди зменшують ймовірність нестабільних тестів. Ці покращення забезпечують стійкість ваших тестів до таких проблем, як затримки ініціалізації веб-представлення або тимчасові стани додатка.

```ts
// Приклад: Розширене перемикання веб-представлення з надійною логікою зіставлення
await driver.switchContext({
  url: /.*my-app\/dashboard/,
  androidWebviewConnectionRetryTime: 500,
  androidWebviewConnectTimeout: 7000,
});
```

Це робить виконання тестів більш передбачуваним і менш схильним до збоїв, спричинених факторами середовища.

### 5. Покращення можливостей налагодження
Розширені команди часто повертають багатше метаданих, що полегшує налагодження складних сценаріїв, особливо в гібридних додатках. Наприклад, команди getContext і getContexts можуть повертати детальну інформацію про веб-представлення, включаючи заголовок, URL та статус видимості.

```ts
// Приклад: Отримання детальних метаданих для налагодження
const contexts = await driver.getContexts({ returnDetailedContexts: true });
console.log(contexts);
```

Ці метадані допомагають швидше ідентифікувати та вирішувати проблеми, покращуючи загальний досвід налагодження.


Розширюючи мобільні команди, WebdriverIO не тільки спрощує автоматизацію, але також відповідає своїй місії надавати розробникам інструменти, які є потужними, надійними та інтуїтивно зрозумілими для використання.

---

## Гібридні додатки

Гібридні додатки поєднують веб-контент з нативною функціональністю і вимагають спеціалізованої обробки під час автоматизації. Ці додатки використовують веб-представлення для відтворення веб-контенту в нативному додатку. WebdriverIO надає розширені методи для ефективної роботи з гібридними додатками.

### Розуміння веб-представлень
Веб-представлення - це компонент на зразок браузера, вбудований у нативний додаток:

- **Android:** Веб-представлення базуються на Chrome/System Webview і можуть містити кілька сторінок (подібно до вкладок браузера). Ці веб-представлення вимагають ChromeDriver для автоматизації взаємодій. Appium може автоматично визначати необхідну версію ChromeDriver на основі версії System WebView або Chrome, встановленої на пристрої, і автоматично завантажувати її, якщо вона ще не доступна. Цей підхід забезпечує безшовну сумісність і мінімізує ручне налаштування. Зверніться до [документації Appium UIAutomator2](https://github.com/appium/appium-uiautomator2-driver?tab=readme-ov-file#automatic-discovery-of-compatible-chromedriver), щоб дізнатися, як Appium автоматично завантажує правильну версію ChromeDriver.
- **iOS:** Веб-представлення працюють на Safari (WebKit) і ідентифікуються загальними ідентифікаторами, такими як `WEBVIEW_{id}`.

### Виклики з гібридними додатками
1. Ідентифікація правильного веб-представлення серед кількох варіантів.
2. Отримання додаткових метаданих, таких як заголовок, URL або назва пакету для кращого контексту.
3. Робота з платформо-специфічними відмінностями між Android та iOS.
4. Надійне перемикання на правильний контекст у гібридному додатку.

### Ключові команди для гібридних додатків

#### 1. `getContext`
Отримує поточний контекст сесії. За замовчуванням поводиться як метод getContext від Appium, але може надавати детальну інформацію про контекст, коли увімкнено `returnDetailedContext`. Додаткову інформацію див. у [`getContext`](/docs/api/mobile/getContext)

#### 2. `getContexts`
Повертає детальний список доступних контекстів, покращуючи метод contexts від Appium. Це полегшує ідентифікацію правильного веб-представлення для взаємодії без виклику додаткових команд для визначення title, url або активного `bundleId|packageName`. Додаткову інформацію див. у [`getContexts`](/docs/api/mobile/getContexts)

#### 3. `switchContext`
Перемикається на певне веб-представлення на основі імені, заголовка або url. Надає додаткову гнучкість, наприклад, використання регулярних виразів для зіставлення. Додаткову інформацію див. у [`switchContext`](/docs/api/mobile/switchContext)

### Ключові особливості для гібридних додатків
1. Детальні метадані: Отримання вичерпних деталей для налагодження та надійного перемикання контексту.
2. Крос-платформна узгодженість: Уніфікована поведінка для Android та iOS, плавна обробка платформо-специфічних особливостей.
3. Власна логіка повторних спроб (Android): Налаштування інтервалів повторних спроб та тайм-аутів для виявлення веб-представлень.


:::info Примітки та обмеження
- Android надає додаткові метадані, такі як `packageName` та `webviewPageId`, тоді як iOS фокусується на `bundleId`.
- Логіка повторних спроб налаштовується для Android, але не застосовується до iOS.
- Існує кілька випадків, коли iOS не може знайти Webview. Appium надає різні додаткові можливості для `appium-xcuitest-driver` для пошуку Webview. Якщо ви вважаєте, що Webview не знайдено, ви можете спробувати встановити одну з наступних можливостей:
    - `appium:includeSafariInWebviews`: Додати веб-контексти Safari до списку контекстів, доступних під час тесту нативного/веб-представлення додатка. Це корисно, якщо тест відкриває Safari і повинен мати можливість взаємодіяти з ним. За замовчуванням `false`.
    - `appium:webviewConnectRetries`: Максимальна кількість повторних спроб перед тим, як відмовитися від виявлення сторінок веб-представлення. Затримка між кожною повторною спробою становить 500 мс, за замовчуванням - `10` повторних спроб.
    - `appium:webviewConnectTimeout`: Максимальний час у мілісекундах для очікування виявлення сторінки веб-представлення. За замовчуванням `5000` мс.

Для розширених прикладів та деталей див. документацію Mobile API WebdriverIO.
:::


---

Наш зростаючий набір команд відображає нашу прихильність до того, щоб зробити мобільну автоматизацію доступною та елегантною. Незалежно від того, чи виконуєте ви складні жести, чи працюєте з елементами нативних додатків, ці команди відповідають філософії WebdriverIO щодо створення безперебійного досвіду автоматизації. І ми не зупиняємося на цьому - якщо є функція, яку ви хотіли б побачити, ми вітаємо ваш відгук. Не соромтеся надсилати свої запити через [це посилання](https://github.com/webdriverio/webdriverio/issues/new/choose).