---
id: mobile
title: モバイルコマンド
---

# WebdriverIOにおけるカスタムおよび拡張モバイルコマンドの紹介

モバイルアプリとモバイルWebアプリケーションのテストには、特にAndroidとiOS間のプラットフォーム固有の違いに対処する際に、独自の課題があります。Appiumはこれらの違いを処理するための柔軟性を提供しますが、複雑なプラットフォーム依存のドキュメント（[Android](https://github.com/appium/appium-uiautomator2-driver/blob/master/docs/android-mobile-gestures.md)、[iOS](https://appium.github.io/appium-xcuitest-driver/latest/reference/execute-methods/)）やコマンドを深く掘り下げる必要があることがよくあります。これにより、テストスクリプトの作成に時間がかかり、エラーが発生しやすく、メンテナンスが難しくなる可能性があります。

このプロセスを簡素化するために、WebdriverIOはモバイルWebおよびネイティブアプリのテスト専用に**カスタムおよび拡張モバイルコマンド**を導入しています。これらのコマンドは、基盤となるAppium APIの複雑さを抽象化し、簡潔で直感的かつプラットフォームに依存しないテストスクリプトを作成できるようにします。使いやすさに重点を置くことで、Appiumスクリプトの開発中の余分な負担を軽減し、モバイルアプリを簡単に自動化できるようにすることを目指しています。

<LiteYouTubeEmbed
    id="tN0LmKgWjPw"
    title="WebdriverIO Tutorials - Enhanced Mobile Commands"
/>

## なぜカスタムモバイルコマンドなのか？

### 1. **複雑なAPIの簡素化**
ジェスチャーや要素の相互作用などのAppiumコマンドは、冗長で複雑な構文を伴うことがあります。たとえば、ネイティブAppium APIで長押しアクションを実行するには、`action`チェーンを手動で構築する必要があります：

```ts
const element = $('~Contacts')

await browser
    .action( 'pointer', { parameters: { pointerType: 'touch' } })
    .move({ origin: element })
    .down()
    .pause(1500)
    .up()
    .perform()
```

WebdriverIOのカスタムコマンドを使用すると、同じアクションを1行の表現力のあるコードで実行できます：

```ts
await $('~Contacts').longPress();
```

これにより、ボイラープレートコードが大幅に削減され、スクリプトがよりクリーンで理解しやすくなります。

### 2. **クロスプラットフォームの抽象化**
モバイルアプリでは、プラットフォーム固有の処理が必要になることがよくあります。たとえば、ネイティブアプリでのスクロールは[Android](https://github.com/appium/appium-uiautomator2-driver/blob/master/docs/android-mobile-gestures.md#mobile-scrollgesture)と[iOS](https://appium.github.io/appium-xcuitest-driver/latest/reference/execute-methods/#mobile-scroll)の間で大きく異なります。WebdriverIOは、基礎となる実装に関係なく、プラットフォーム間でシームレスに機能する`scrollIntoView()`のような統一されたコマンドを提供することで、このギャップを埋めます。

```ts
await $('~element').scrollIntoView();
```

この抽象化により、テストが移植可能で、OS間の違いを考慮するための常に分岐や条件付きロジックを必要としないことを保証します。

### 3. **生産性の向上**
低レベルのAppiumコマンドを理解して実装する必要性を減らすことで、WebdriverIOのモバイルコマンドを使用すると、プラットフォーム固有のニュアンスと格闘するのではなく、アプリの機能のテストに集中できます。これは、モバイル自動化の経験が限られているチームや開発サイクルを加速したいチームにとって特に有益です。

### 4. **一貫性とメンテナンス性**
カスタムコマンドはテストスクリプトに統一性をもたらします。同様のアクションに対してさまざまな実装を持つ代わりに、チームは標準化された再利用可能なコマンドに頼ることができます。これはコードベースをより保守可能にするだけでなく、新しいチームメンバーのオンボーディングの障壁も下げます。

## なぜ特定のモバイルコマンドを拡張するのか？

### 1. 柔軟性の追加
特定のモバイルコマンドは、デフォルトのAppium APIでは利用できない追加のオプションとパラメータを提供するために拡張されています。たとえば、WebdriverIOは再試行ロジック、タイムアウト、特定の基準でウェブビューをフィルタリングする機能を追加し、複雑なシナリオをより制御できるようにします。

```ts
// 例：ウェブビュー検出の再試行間隔とタイムアウトのカスタマイズ
await driver.getContexts({
  returnDetailedContexts: true,
  androidWebviewConnectionRetryTime: 1000, // 1秒ごとに再試行
  androidWebviewConnectTimeout: 10000,    // 10秒後にタイムアウト
});
```

これらのオプションは、追加のボイラープレートコードなしに動的なアプリの動作に自動化スクリプトを適応させるのに役立ちます。

### 2. 使いやすさの向上
拡張コマンドは、ネイティブAPIに見られる複雑さと繰り返しパターンを抽象化します。より少ないコード行でより多くのアクションを実行できるため、新しいユーザーの学習曲線が減少し、スクリプトが読みやすく維持しやすくなります。

```ts
// 例：タイトルによるコンテキスト切り替えの拡張コマンド
await driver.switchContext({
  title: 'My Webview Title',
});
```

デフォルトのAppiumメソッドと比較して、拡張コマンドは利用可能なコンテキストを手動で取得してフィルタリングするなどの追加ステップを排除します。

### 3. 動作の標準化
WebdriverIOは、拡張コマンドがAndroidやiOSなどのプラットフォーム間で一貫して動作することを保証します。このクロスプラットフォームの抽象化により、オペレーティングシステムに基づいて条件分岐ロジックの必要性が最小限に抑えられ、より保守しやすいテストスクリプトが生成されます。

```ts
// 例：両プラットフォーム用の統一されたスクロールコマンド
await $('~element').scrollIntoView();
```

この標準化は、特に複数のプラットフォームでテストを自動化するチームのコードベースを簡素化します。

### 4. 信頼性の向上
再試行メカニズム、スマートデフォルト、詳細なエラーメッセージを組み込むことで、拡張コマンドは不安定なテストの可能性を減らします。これらの改善により、ウェブビューの初期化の遅延や一時的なアプリの状態などの問題に対してテストが弾力性を持つことが保証されます。

```ts
// 例：堅牢なマッチングロジックを備えた拡張ウェブビュー切り替え
await driver.switchContext({
  url: /.*my-app\/dashboard/,
  androidWebviewConnectionRetryTime: 500,
  androidWebviewConnectTimeout: 7000,
});
```

これにより、テスト実行がより予測可能になり、環境要因によって引き起こされる障害が少なくなります。

### 5. デバッグ機能の強化
拡張コマンドはしばしばより豊富なメタデータを返し、特にハイブリッドアプリでの複雑なシナリオのデバッグを容易にします。たとえば、getContextやgetContextsなどのコマンドは、タイトル、URL、可視性ステータスなど、ウェブビューに関する詳細情報を返すことができます。

```ts
// 例：デバッグ用の詳細メタデータの取得
const contexts = await driver.getContexts({ returnDetailedContexts: true });
console.log(contexts);
```

このメタデータは問題をより迅速に特定して解決するのに役立ち、全体的なデバッグ体験を向上させます。


モバイルコマンドを拡張することで、WebdriverIOは自動化を容易にするだけでなく、強力で信頼性が高く、直感的に使用できるツールを開発者に提供するというミッションにも沿っています。

---

## ハイブリッドアプリ

ハイブリッドアプリはウェブコンテンツとネイティブ機能を組み合わせ、自動化中に特殊な処理が必要です。これらのアプリはネイティブアプリケーション内でウェブコンテンツをレンダリングするためにウェブビューを使用します。WebdriverIOはハイブリッドアプリを効果的に操作するための拡張メソッドを提供しています。

### ウェブビューの理解
ウェブビューはネイティブアプリに埋め込まれたブラウザのようなコンポーネントです：

- **Android：** ウェブビューはChrome/System Webviewに基づいており、複数のページ（ブラウザタブに似ています）を含む場合があります。これらのウェブビューは、相互作用を自動化するためにChromeDriverが必要です。Appiumは、デバイスにインストールされているSystem WebViewまたはChromeのバージョンに基づいて必要なChromeDriverバージョンを自動的に決定し、まだ利用可能でない場合は自動的にダウンロードすることができます。このアプローチにより、シームレスな互換性が確保され、手動セットアップが最小限に抑えられます。AppiumがどのようにChromeDriverの正しいバージョンを自動的にダウンロードするかについては、[Appium UIAutomator2-documentation](https://github.com/appium/appium-uiautomator2-driver?tab=readme-ov-file#automatic-discovery-of-compatible-chromedriver)を参照してください。
- **iOS：** ウェブビューはSafari（WebKit）によって動作し、`WEBVIEW_{id}`のような一般的なIDで識別されます。

### ハイブリッドアプリの課題
1. 複数のオプションの中から正しいウェブビューを識別すること。
2. より良いコンテキストのためにタイトル、URL、またはパッケージ名などの追加メタデータを取得すること。
3. AndroidとiOS間のプラットフォーム固有の違いを処理すること。
4. ハイブリッドアプリで正しいコンテキストに確実に切り替えること。

### ハイブリッドアプリの主要コマンド

#### 1. `getContext`
セッションの現在のコンテキストを取得します。デフォルトでは、AppiumのgetContextメソッドのように動作しますが、`returnDetailedContext`が有効になっている場合は詳細なコンテキスト情報を提供できます。詳細については[`getContext`](/docs/api/mobile/getContext)を参照してください。

#### 2. `getContexts`
利用可能なコンテキストの詳細なリストを返し、Appiumのcontextsメソッドを改良します。これにより、タイトル、url、またはアクティブな`bundleId|packageName`を決定するための追加のコマンドを呼び出さずに、相互作用のための正しいウェブビューを特定しやすくなります。詳細については[`getContexts`](/docs/api/mobile/getContexts)を参照してください。

#### 3. `switchContext`
名前、タイトル、またはURLに基づいて特定のウェブビューに切り替えます。マッチングに正規表現を使用するなど、追加の柔軟性を提供します。詳細については[`switchContext`](/docs/api/mobile/switchContext)を参照してください。

### ハイブリッドアプリの主要機能
1. 詳細なメタデータ：デバッグと信頼性の高いコンテキスト切り替えのための包括的な詳細を取得します。
2. クロスプラットフォームの一貫性：AndroidとiOSに対して統一された動作を提供し、プラットフォーム固有の問題をシームレスに処理します。
3. カスタム再試行ロジック（Android）：ウェブビュー検出の再試行間隔とタイムアウトを調整します。


:::info 注意事項と制限
- Androidは`packageName`や`webviewPageId`などの追加メタデータを提供しますが、iOSは`bundleId`に焦点を当てています。
- 再試行ロジックはAndroidでカスタマイズ可能ですが、iOSには適用されません。
- iOSでウェブビューを見つけられないケースがいくつかあります。Appiumは`appium-xcuitest-driver`のためにウェブビューを見つけるための異なる追加機能を提供しています。ウェブビューが見つからないと思われる場合は、次のいずれかの機能を設定してみてください：
    - `appium:includeSafariInWebviews`：ネイティブ/ウェブビューアプリテスト中に利用可能なコンテキストのリストにSafariウェブコンテキストを追加します。これは、テストがSafariを開き、それと相互作用する必要がある場合に便利です。デフォルトは`false`です。
    - `appium:webviewConnectRetries`：ウェブビューページの検出を諦める前の最大再試行回数。各再試行間の遅延は500msで、デフォルトは`10`回の再試行です。
    - `appium:webviewConnectTimeout`：ウェブビューページが検出されるのを待つ最大時間（ミリ秒単位）。デフォルトは`5000`msです。

高度な例と詳細については、WebdriverIO Mobile APIドキュメントを参照してください。
:::


---

私たちの成長し続けるコマンドセットは、モバイル自動化をアクセスしやすく優雅にするという私たちの取り組みを反映しています。複雑なジェスチャーを実行するか、ネイティブアプリ要素で作業するかにかかわらず、これらのコマンドはWebdriverIOのシームレスな自動化体験を作成するという哲学に沿っています。そして、ここで止まるつもりはありません—あなたが見たい機能がある場合は、あなたのフィードバックを歓迎します。[このリンク](https://github.com/webdriverio/webdriverio/issues/new/choose)からリクエストを提出してください。