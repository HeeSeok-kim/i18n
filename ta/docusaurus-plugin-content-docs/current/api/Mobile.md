---
id: mobile
title: மொபைல் கட்டளைகள்
---

# WebdriverIO-இல் தனிப்பயன் மற்றும் மேம்படுத்தப்பட்ட மொபைல் கட்டளைகளுக்கான அறிமுகம்

மொபைல் பயன்பாடுகள் மற்றும் மொபைல் வலை பயன்பாடுகளை சோதிப்பது அதன் சொந்த சவால்களை கொண்டுள்ளது, குறிப்பாக ஆண்ட்ராய்டு மற்றும் iOS இடையே உள்ள தளம் சார்ந்த வேறுபாடுகளை கையாளும்போது. Appium இந்த வேறுபாடுகளை கையாள நெகிழ்வுத்தன்மையை வழங்கும் போதிலும், அது அடிக்கடி தளம் சார்ந்த ஆவணங்களில் ([ஆண்ட்ராய்டு](https://github.com/appium/appium-uiautomator2-driver/blob/master/docs/android-mobile-gestures.md), [iOS](https://appium.github.io/appium-xcuitest-driver/latest/reference/execute-methods/)) மற்றும் கட்டளைகளில் ஆழமாக ஆராய வேண்டியுள்ளது. இது சோதனை ஸ்கிரிப்டுகளை எழுதுவதை அதிக நேரம் எடுக்கும், பிழை ஏற்படும் வாய்ப்புள்ள, மற்றும் பராமரிப்பதற்கு கடினமாக்குகிறது.

இந்த செயல்முறையை எளிமையாக்க, WebdriverIO **தனிப்பயன் மற்றும் மேம்படுத்தப்பட்ட மொபைல் கட்டளைகளை** மொபைல் வலை மற்றும் நேட்டிவ் பயன்பாட்டு சோதனைக்காக உருவாக்கியுள்ளது. இந்த கட்டளைகள் அடிப்படையில் உள்ள Appium API-களின் சிக்கல்களை மறைத்து, சுருக்கமான, புரிந்துகொள்ளக்கூடிய, மற்றும் தளம் சார்பற்ற சோதனை ஸ்கிரிப்டுகளை எழுத உங்களை அனுமதிக்கின்றன. பயன்படுத்துவதில் எளிமையை கவனம் செலுத்துவதன் மூலம், நாங்கள் Appium ஸ்கிரிப்டுகளை உருவாக்கும்போது கூடுதல் சுமையை குறைக்க நோக்கம் கொண்டுள்ளோம் மற்றும் மொபைல் பயன்பாடுகளை எளிதாக தானியங்கு முறையில் இயக்க உங்களை அதிகாரப்படுத்துகிறோம்.

<LiteYouTubeEmbed
    id="tN0LmKgWjPw"
    title="WebdriverIO Tutorials - Enhanced Mobile Commands"
/>

## ஏன் தனிப்பயன் மொபைல் கட்டளைகள்?

### 1. **சிக்கலான API-களை எளிமைப்படுத்துதல்**
சில Appium கட்டளைகள், சைகைகள் அல்லது உறுப்புகளின் தொடர்புகள் போன்றவை, விரிவான மற்றும் சிக்கலான தொடரியலை உள்ளடக்கியது. எடுத்துக்காட்டாக, நேட்டிவ் Appium API உடன் நீண்ட அழுத்த செயலை நிறைவேற்ற `action` சங்கிலியை கைமுறையாக உருவாக்க வேண்டும்:

```ts
const element = $('~Contacts')

await browser
    .action( 'pointer', { parameters: { pointerType: 'touch' } })
    .move({ origin: element })
    .down()
    .pause(1500)
    .up()
    .perform()
```

WebdriverIO-இன் தனிப்பயன் கட்டளைகளுடன், அதே செயலை ஒரு எளிய, வெளிப்படையான வரியின் மூலம் செய்ய முடியும்:

```ts
await $('~Contacts').longPress();
```

இது பெரிதும் கோட்டு அடிப்படை குறியீட்டை குறைக்கிறது, உங்கள் ஸ்கிரிப்டுகளை சுத்தமாகவும் புரிந்துகொள்ள எளிதாகவும் மாற்றுகிறது.

### 2. **குறுக்கு-தள சுருக்கம்**
மொபைல் பயன்பாடுகள் அடிக்கடி தளம் சார்ந்த கையாளுதலை தேவைப்படுத்துகின்றன. எடுத்துக்காட்டாக, நேட்டிவ் பயன்பாடுகளில் ஸ்க்ரோலிங் [ஆண்ட்ராய்டு](https://github.com/appium/appium-uiautomator2-driver/blob/master/docs/android-mobile-gestures.md#mobile-scrollgesture) மற்றும் [iOS](https://appium.github.io/appium-xcuitest-driver/latest/reference/execute-methods/#mobile-scroll) இடையே கணிசமாக வேறுபடுகிறது. WebdriverIO இந்த இடைவெளியை `scrollIntoView()` போன்ற ஒருங்கிணைந்த கட்டளைகளை வழங்குவதன் மூலம் பாலம் ஏற்படுத்துகிறது, இவை அடிப்படை அமலாக்கத்தைப் பொருட்படுத்தாமல் பல தளங்களில் சீராக வேலை செய்கின்றன.

```ts
await $('~element').scrollIntoView();
```

இந்த சுருக்கம் உங்கள் சோதனைகள் எளிதில் மாற்றக்கூடியவை என்பதை உறுதி செய்கிறது மற்றும் OS வேறுபாடுகளை கணக்கில் கொள்ள தொடர்ந்து கிளையாக்கம் அல்லது நிபந்தனை தர்க்கம் தேவைப்படாது.

### 3. **அதிகரித்த உற்பத்தித்திறன்**
குறைந்த-நிலை Appium கட்டளைகளைப் புரிந்துகொள்ளவும் செயல்படுத்தவும் தேவையைக் குறைப்பதன் மூலம், WebdriverIO-இன் மொபைல் கட்டளைகள் தளம் சார்ந்த சுருக்கங்களை கையாளுவதற்கு பதிலாக உங்கள் பயன்பாட்டின் செயல்பாட்டை சோதிப்பதில் கவனம் செலுத்த உங்களை அனுமதிக்கின்றன. இது குறிப்பாக மொபைல் தானியங்குமயமாக்கல் குறித்த வரையறுக்கப்பட்ட அனுபவம் கொண்ட குழுக்களுக்கு அல்லது தங்கள் மேம்பாட்டு சுழற்சியை துரிதப்படுத்த விரும்புபவர்களுக்கு பயனுள்ளதாக இருக்கும்.

### 4. **நிலைத்தன்மை மற்றும் பராமரிப்பு திறன்**
தனிப்பயன் கட்டளைகள் உங்கள் சோதனை ஸ்கிரிப்டுகளுக்கு ஒரே சீரான தன்மையை கொண்டு வருகிறது. அதே போன்ற செயல்களுக்கு மாறுபட்ட அமலாக்கங்களைக் கொண்டிருப்பதற்கு பதிலாக, உங்கள் குழு தரப்படுத்தப்பட்ட, மறுபயன்பாட்டு கட்டளைகளை நம்பலாம். இது கோட்டிங்களை அதிக பராமரிக்கக்கூடியதாக மட்டுமல்லாமல், புதிய குழு உறுப்பினர்களை அறிமுகப்படுத்துவதற்கான தடையையும் குறைக்கிறது.

## ஏன் சில மொபைல் கட்டளைகளை மேம்படுத்த வேண்டும்?

### 1. நெகிழ்வுத்தன்மையை சேர்த்தல்
சில மொபைல் கட்டளைகள் இயல்புநிலை Appium API-களில் இல்லாத கூடுதல் விருப்பங்கள் மற்றும் அளவுருக்களை வழங்குவதற்காக மேம்படுத்தப்படுகின்றன. எடுத்துக்காட்டாக, WebdriverIO மறுமுயற்சி தர்க்கம், காலமுடிவுகள், மற்றும் குறிப்பிட்ட அளவுகோல்களால் webviews வடிகட்டும் திறனை சேர்க்கிறது, சிக்கலான சூழ்நிலைகளை அதிக கட்டுப்பாட்டுடன் இயக்க அனுமதிக்கிறது.

```ts
// Example: Customizing retry intervals and timeouts for webview detection
await driver.getContexts({
  returnDetailedContexts: true,
  androidWebviewConnectionRetryTime: 1000, // Retry every 1 second
  androidWebviewConnectTimeout: 10000,    // Timeout after 10 seconds
});
```

இந்த விருப்பங்கள் கூடுதல் அடிப்படை குறியீடு இல்லாமல் மாறுபட்ட பயன்பாட்டு நடத்தைக்கு தானியங்கு ஸ்கிரிப்டுகளை தகவமைக்க உதவுகின்றன.

### 2. பயன்பாட்டை மேம்படுத்துதல்
மேம்படுத்தப்பட்ட கட்டளைகள் நேட்டிவ் API-களில் காணப்படும் சிக்கல்கள் மற்றும் மீண்டும் மீண்டும் வரும் முறைகளை மறைக்கின்றன. அவை குறைவான வரிகளில் அதிக செயல்களை செய்ய உங்களை அனுமதிக்கின்றன, புதிய பயனர்களுக்கான கற்றல் வளைவைக் குறைத்து, ஸ்கிரிப்டுகளை படிக்கவும் பராமரிக்கவும் எளிதாக்குகின்றன.

```ts
// Example: Enhanced command for switching context by title
await driver.switchContext({
  title: 'My Webview Title',
});
```

இயல்புநிலை Appium முறைகளுடன் ஒப்பிடும்போது, மேம்படுத்தப்பட்ட கட்டளைகள் கிடைக்கக்கூடிய சூழல்களை கைமுறையாக பெறுவது மற்றும் அவற்றை வடிகட்டுவது போன்ற கூடுதல் படிகளுக்கான தேவையை நீக்குகின்றன.

### 3. நடத்தையை தரப்படுத்துதல்
WebdriverIO மேம்படுத்தப்பட்ட கட்டளைகள் ஆண்ட்ராய்டு மற்றும் iOS போன்ற தளங்களில் நிலையாக நடந்துகொள்வதை உறுதி செய்கிறது. இந்த குறுக்கு-தள சுருக்கம் இயக்க முறைமையை அடிப்படையாகக் கொண்டு நிபந்தனை கிளையாக்கம் தர்க்கத்திற்கான தேவையைக் குறைக்கிறது, இது அதிக பராமரிக்கக்கூடிய சோதனை ஸ்கிரிப்டுகளுக்கு வழிவகுக்கிறது.

```ts
// Example: Unified scroll command for both platforms
await $('~element').scrollIntoView();
```

இந்த தரப்படுத்தல் குறிப்பாக பல தளங்களில் சோதனைகளை தானியங்குபடுத்தும் குழுக்களுக்கு கோட்டிங்களை எளிமைப்படுத்துகிறது.

### 4. நம்பகத்தன்மையை அதிகரித்தல்
மறுமுயற்சி பொறிமுறைகள், ஸ்மார்ட் இயல்புநிலைகள் மற்றும் விரிவான பிழை செய்திகளை ஒருங்கிணைப்பதன் மூலம், மேம்படுத்தப்பட்ட கட்டளைகள் பிளக்கி சோதனைகளின் வாய்ப்பைக் குறைக்கின்றன. இந்த மேம்பாடுகள் webview துவக்கத்தில் தாமதங்கள் அல்லது நிலையற்ற பயன்பாட்டு நிலைகள் போன்ற சிக்கல்களுக்கு உங்கள் சோதனைகள் நெகிழ்வுத்தன்மை உடையதாக இருப்பதை உறுதி செய்கின்றன.

```ts
// Example: Enhanced webview switching with robust matching logic
await driver.switchContext({
  url: /.*my-app\/dashboard/,
  androidWebviewConnectionRetryTime: 500,
  androidWebviewConnectTimeout: 7000,
});
```

இது சோதனை செயல்பாட்டை அதிக கணிக்கக்கூடியதாகவும், சுற்றுச்சூழல் காரணிகளால் ஏற்படும் தோல்விகளுக்கு குறைவாக உள்ளாகும் வாய்ப்பும் உள்ளது.

### 5. பிழைத்திருத்த திறன்களை மேம்படுத்துதல்
மேம்படுத்தப்பட்ட கட்டளைகள் பெரும்பாலும் செழுமையான மெட்டாடேட்டாவை வழங்குகின்றன, குறிப்பாக ஹைபிரிட் பயன்பாடுகளில் சிக்கலான சூழ்நிலைகளை எளிதாக பிழைத்திருத்த அனுமதிக்கின்றன. எடுத்துக்காட்டாக, getContext மற்றும் getContexts போன்ற கட்டளைகள் தலைப்பு, url, மற்றும் காட்சி நிலை உள்ளிட்ட webviews பற்றிய விரிவான தகவல்களை திருப்பி அனுப்ப முடியும்.

```ts
// Example: Retrieving detailed metadata for debugging
const contexts = await driver.getContexts({ returnDetailedContexts: true });
console.log(contexts);
```

இந்த மெட்டாடேட்டா சிக்கல்களை விரைவாக கண்டறிந்து தீர்க்க உதவுகிறது, ஒட்டுமொத்த பிழைத்திருத்த அனுபவத்தை மேம்படுத்துகிறது.


மொபைல் கட்டளைகளை மேம்படுத்துவதன் மூலம், WebdriverIO தானியங்குமயமாக்கலை எளிதாக்குவதோடு மட்டுமல்லாமல், சக்திவாய்ந்த, நம்பகமான, மற்றும் பயன்படுத்த எளிதான கருவிகளை உருவாக்குவோருக்கு வழங்குவதற்கான அதன் பணியுடனும் இணைகிறது.

---

## ஹைபிரிட் பயன்பாடுகள்

ஹைபிரிட் பயன்பாடுகள் வலை உள்ளடக்கத்தை நேட்டிவ் செயல்பாட்டுடன் இணைக்கின்றன மற்றும் தானியங்குமயமாக்கலின் போது சிறப்பு கையாளுதல் தேவைப்படுகிறது. இந்த பயன்பாடுகள் நேட்டிவ் பயன்பாட்டிற்குள் வலை உள்ளடக்கத்தை காட்ட webviews ஐப் பயன்படுத்துகின்றன. WebdriverIO ஹைபிரிட் பயன்பாடுகளுடன் பயனுள்ள முறையில் வேலை செய்ய மேம்படுத்தப்பட்ட முறைகளை வழங்குகிறது.

### Webviews புரிந்துகொள்ளுதல்
Webview என்பது நேட்டிவ் பயன்பாட்டில் பொதிந்துள்ள உலாவி போன்ற கூறாகும்:

- **ஆண்ட்ராய்டு:** Webviews Chrome/System Webview அடிப்படையில் அமைந்துள்ளன மற்றும் பல பக்கங்களை (உலாவி தாவல்கள் போல) கொண்டிருக்கலாம். இந்த webviews தொடர்புகளை தானியங்குபடுத்த ChromeDriver தேவைப்படுகிறது. Appium தானாகவே சாதனத்தில் நிறுவப்பட்டுள்ள System WebView அல்லது Chrome பதிப்பின் அடிப்படையில் தேவையான ChromeDriver பதிப்பைத் தீர்மானிக்கவும், ஏற்கனவே இல்லை என்றால் தானாகவே பதிவிறக்கவும் முடியும். இந்த அணுகுமுறை சீரான இணக்கத்தன்மையை உறுதி செய்கிறது மற்றும் கைமுறை அமைப்பை குறைக்கிறது. Appium எவ்வாறு தானாகவே சரியான ChromeDriver பதிப்பை பதிவிறக்குகிறது என்பதை அறிய [Appium UIAutomator2-ஆவணங்களைப்](https://github.com/appium/appium-uiautomator2-driver?tab=readme-ov-file#automatic-discovery-of-compatible-chromedriver) பார்க்கவும்.
- **iOS:** Webviews Safari (WebKit) ஆல் இயக்கப்படுகின்றன மற்றும் `WEBVIEW_{id}` போன்ற பொதுவான IDs மூலம் அடையாளம் காணப்படுகின்றன.

### ஹைபிரிட் பயன்பாடுகளுடனான சவால்கள்
1. பல விருப்பங்களில் இருந்து சரியான webview ஐ அடையாளம் காணுதல்.
2. சிறந்த சூழலுக்காக தலைப்பு, URL, அல்லது பாக்கேஜ் பெயர் போன்ற கூடுதல் மெட்டாடேட்டாவைப் பெறுதல்.
3. ஆண்ட்ராய்டு மற்றும் iOS இடையேயான தளம் சார்ந்த வேறுபாடுகளைக் கையாளுதல்.
4. ஹைபிரிட் பயன்பாட்டில் சரியான சூழலுக்கு நம்பகமாக மாறுதல்.

### ஹைபிரிட் பயன்பாடுகளுக்கான முக்கிய கட்டளைகள்

#### 1. `getContext`
அமர்வின் தற்போதைய சூழலைப் பெறுகிறது. இயல்பாக, இது Appium-இன் getContext முறையைப் போலவே செயல்படுகிறது, ஆனால் `returnDetailedContext` இயக்கப்படும்போது விரிவான சூழல் தகவலை வழங்கும். மேலும் தகவலுக்கு [`getContext`](/docs/api/mobile/getContext) ஐப் பார்க்கவும்

#### 2. `getContexts`
கிடைக்கக்கூடிய சூழல்களின் விரிவான பட்டியலை வழங்குகிறது, Appium-இன் contexts முறையை மேம்படுத்துகிறது. இது தலைப்பு, url அல்லது செயலில் உள்ள `bundleId|packageName` தீர்மானிக்க கூடுதல் கட்டளைகளை அழைக்காமல் தொடர்புக்கான சரியான webview ஐ அடையாளம் காண எளிதாக்குகிறது. மேலும் தகவலுக்கு [`getContexts`](/docs/api/mobile/getContexts) ஐப் பார்க்கவும்

#### 3. `switchContext`
பெயர், தலைப்பு அல்லது url அடிப்படையில் ஒரு குறிப்பிட்ட webview க்கு மாறுகிறது. பொருத்தத்திற்கு வழக்கமான வெளிப்பாடுகளைப் பயன்படுத்துதல் போன்ற கூடுதல் நெகிழ்வுத்தன்மையை வழங்குகிறது. மேலும் தகவலுக்கு [`switchContext`](/docs/api/mobile/switchContext) ஐப் பார்க்கவும்

### ஹைபிரிட் பயன்பாடுகளுக்கான முக்கிய அம்சங்கள்
1. விரிவான மெட்டாடேட்டா: பிழைத்திருத்தம் மற்றும் நம்பகமான சூழல் மாற்றத்திற்கான விரிவான விவரங்களைப் பெறுங்கள்.
2. குறுக்கு-தள நிலைத்தன்மை: ஆண்ட்ராய்டு மற்றும் iOS க்கான ஒருங்கிணைந்த நடத்தை, தளம் சார்ந்த சிறப்பம்சங்களை சீராக கையாளுதல்.
3. தனிப்பயன் மறுமுயற்சி தர்க்கம் (ஆண்ட்ராய்டு): webview கண்டறிதலுக்கான மறுமுயற்சி இடைவெளிகள் மற்றும் காலமுடிவுகளை சரிசெய்தல்.


:::info குறிப்புகள் மற்றும் வரம்புகள்
- ஆண்ட்ராய்டு `packageName` மற்றும் `webviewPageId` போன்ற கூடுதல் மெட்டாடேட்டாவை வழங்குகிறது, அதே சமயம் iOS `bundleId` மீது கவனம் செலுத்துகிறது.
- மறுமுயற்சி தர்க்கம் ஆண்ட்ராய்டுக்கு தனிப்பயனாக்கக்கூடியது ஆனால் iOS க்கு பொருந்தாது.
- iOS Webview ஐக் கண்டறிய முடியாத பல சந்தர்ப்பங்கள் உள்ளன. Appium `appium-xcuitest-driver` க்கான பல்வேறு கூடுதல் திறன்களை வழங்குகிறது, Webview ஐக் கண்டறிய. Webview கண்டுபிடிக்கப்படவில்லை என்று நீங்கள் நம்பினால், பின்வரும் திறன்களில் ஒன்றை அமைக்க முயற்சிக்கலாம்:
    - `appium:includeSafariInWebviews`: நேட்டிவ்/வெப்வியூ பயன்பாட்டு சோதனையின் போது கிடைக்கும் சூழல்களின் பட்டியலில் Safari வலை சூழல்களைச் சேர்க்கவும். இது சோதனை Safari ஐத் திறந்து அதனுடன் தொடர்புகொள்ள வேண்டியிருந்தால் பயனுள்ளதாக இருக்கும். இயல்பாக `false`.
    - `appium:webviewConnectRetries`: வலை காட்சி பக்கங்களைக் கண்டறிவதை கைவிடுவதற்கு முன்பு அதிகபட்ச மறுமுயற்சிகள். ஒவ்வொரு மறுமுயற்சிக்கும் இடையேயான தாமதம் 500ms, இயல்பு `10` மறுமுயற்சிகள்.
    - `appium:webviewConnectTimeout`: வலை காட்சி பக்கம் கண்டறியப்படுவதற்காக காத்திருக்க அதிகபட்ச நேரம் மில்லி வினாடிகளில். இயல்பு `5000` ms.

மேம்பட்ட எடுத்துக்காட்டுகள் மற்றும் விவரங்களுக்கு, WebdriverIO மொபைல் API ஆவணங்களைப் பார்க்கவும்.
:::


---

எங்களின் வளர்ந்து வரும் கட்டளைகளின் தொகுப்பு மொபைல் தானியங்குமயமாக்கலை அணுகக்கூடியதாகவும் அழகாகவும் மாற்றுவதற்கான எங்கள் பொறுப்பை பிரதிபலிக்கிறது. நீங்கள் சிக்கலான சைகைகளை செய்தாலும் அல்லது நேட்டிவ் பயன்பாட்டு உறுப்புகளுடன் வேலை செய்தாலும், இந்த கட்டளைகள் சீரான தானியங்குமய அனுபவத்தை உருவாக்குவதற்கான WebdriverIO-இன் தத்துவத்துடன் இணைகின்றன. மேலும் நாங்கள் இங்கே நிறுத்தவில்லை - நீங்கள் பார்க்க விரும்பும் அம்சம் இருந்தால், உங்கள் கருத்துக்களை வரவேற்கிறோம். [இந்த இணைப்பின்](https://github.com/webdriverio/webdriverio/issues/new/choose) மூலம் உங்கள் கோரிக்கைகளை சமர்ப்பிக்க தயங்க வேண்டாம்.