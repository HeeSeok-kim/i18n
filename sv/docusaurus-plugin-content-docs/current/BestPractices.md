---
id: bestpractices
title: B칛sta praxis
---

# B칛sta praxis

Denna guide syftar till att dela v친ra b칛sta metoder som hj칛lper dig att skriva prestandaoptimerade och robusta tester.

## Anv칛nd robusta selektorer

Genom att anv칛nda selektorer som 칛r motst친ndskraftiga mot f칬r칛ndringar i DOM:en kommer du att ha f칛rre eller inga tester som misslyckas n칛r till exempel en klass tas bort fr친n ett element.

Klasser kan till칛mpas p친 flera element och b칬r undvikas om m칬jligt, s친vida du inte medvetet vill h칛mta alla element med den klassen.

```js
// 游녩
await $('.button')
```

Alla dessa selektorer b칬r returnera ett enda element.

```js
// 游녨
await $('aria/Submit')
await $('[test-id="submit-button"]')
await $('#submit-button')
```

__Obs:__ F칬r att ta reda p친 alla m칬jliga selektorer som WebdriverIO st칬der, kolla in v친r [Selectors](./Selectors.md) sida.

## Begr칛nsa m칛ngden elementfr친gor

Varje g친ng du anv칛nder kommandot [`$`](https://webdriver.io/docs/api/browser/$) eller [`$$`](https://webdriver.io/docs/api/browser/$$) (detta inkluderar kedjning av dem), f칬rs칬ker WebdriverIO lokalisera elementet i DOM:en. Dessa fr친gor 칛r kostsamma s친 du b칬r f칬rs칬ka begr칛nsa dem s친 mycket som m칬jligt.

Fr친gar efter tre element.

```js
// 游녩
await $('table').$('tr').$('td')
```

Fr친gar endast efter ett element.

``` js
// 游녨
await $('table tr td')
```

Den enda g친ngen du b칬r anv칛nda kedjning 칛r n칛r du vill kombinera olika [selektorstrategier](https://webdriver.io/docs/selectors/#custom-selector-strategies).
I exemplet anv칛nder vi [Deep Selectors](https://webdriver.io/docs/selectors#deep-selectors), vilket 칛r en strategi f칬r att g친 in i shadow DOM f칬r ett element.

``` js
// 游녨
await $('custom-datepicker').$('#calendar').$('aria/Select')
```

### F칬redra att lokalisera ett enda element ist칛llet f칬r att ta ett fr친n en lista

Det 칛r inte alltid m칬jligt att g칬ra detta, men med hj칛lp av CSS-pseudoklasser som [:nth-child](https://developer.mozilla.org/en-US/docs/Web/CSS/:nth-child) kan du matcha element baserat p친 indexet f칬r elementen i barnlistan hos deras f칬r칛ldrar.

Fr친gar efter alla tabellrader.

```js
// 游녩
await $$('table tr')[15]
```

Fr친gar efter en enda tabellrad.

```js
// 游녨
await $('table tr:nth-child(15)')
```

## Anv칛nd de inbyggda bekr칛ftelserna

Anv칛nd inte manuella bekr칛ftelser som inte automatiskt v칛ntar p친 att resultaten ska matcha, eftersom detta kommer att orsaka instabila tester.

```js
// 游녩
expect(await button.isDisplayed()).toBe(true)
```

Genom att anv칛nda de inbyggda bekr칛ftelserna kommer WebdriverIO automatiskt att v칛nta p친 att det faktiska resultatet ska matcha det f칬rv칛ntade resultatet, vilket leder till robusta tester.
Det uppn친r detta genom att automatiskt f칬rs칬ka bekr칛ftelsen igen tills den g친r igenom eller n친r tidsgr칛nsen.

```js
// 游녨
await expect(button).toBeDisplayed()
```

## Lat laddning och l칬fteskedjning

WebdriverIO har n친gra tricks n칛r det g칛ller att skriva ren kod eftersom det kan ladda elementet p친 ett "lat" s칛tt, vilket g칬r att du kan kedja dina l칬ften och minskar m칛ngden `await`. Detta g칬r det ocks친 m칬jligt att skicka elementet som ett ChainablePromiseElement ist칛llet f칬r ett Element och f칬r enklare anv칛ndning med sidobjekt.

S친 n칛r m친ste du anv칛nda `await`?
Du b칬r alltid anv칛nda `await` med undantag f칬r kommandona `$` och `$$`.

```js
// 游녩
const div = await $('div')
const button = await div.$('button')
await button.click()
// eller
await (await (await $('div')).$('button')).click()
```

```js
// 游녨
const button = $('div').$('button')
await button.click()
// eller
await $('div').$('button').click()
```

## 칐veranv칛nd inte kommandon och bekr칛ftelser

N칛r du anv칛nder expect.toBeDisplayed v칛ntar du implicit 칛ven p친 att elementet ska existera. Det finns inget behov av att anv칛nda waitForXXX-kommandon n칛r du redan har en bekr칛ftelse som g칬r samma sak.

```js
// 游녩
await button.waitForExist()
await expect(button).toBeDisplayed()

// 游녩
await button.waitForDisplayed()
await expect(button).toBeDisplayed()

// 游녨
await expect(button).toBeDisplayed()
```

Inget behov av att v칛nta p친 att ett element ska existera eller visas vid interaktion eller n칛r man bekr칛ftar n친got som dess text, s친vida elementet inte uttryckligen kan vara osynligt (opacity: 0 till exempel) eller uttryckligen kan vara inaktiverat (disabled-attribut till exempel), i vilket fall det 칛r rimligt att v칛nta p친 att elementet ska visas.

```js
// 游녩
await expect(button).toBeExisting()
await expect(button).toHaveText('Submit')

// 游녩
await expect(button).toBeDisplayed()
await expect(button).toHaveText('Submit')

// 游녩
await expect(button).toBeDisplayed()
await button.click()
```

```js
// 游녨
await button.click()

// 游녨
await expect(button).toHaveText('Submit')
```

## Dynamiska tester

Anv칛nd milj칬variabler f칬r att lagra dynamiska testdata, t.ex. hemliga uppgifter, i din milj칬 ist칛llet f칬r att h친rdkoda dem i testet. G친 칬ver till sidan [Parameterize Tests](parameterize-tests) f칬r mer information om detta 칛mne.

## Linta din kod

Genom att anv칛nda eslint f칬r att linta din kod kan du potentiellt uppt칛cka fel tidigt. Anv칛nd v친ra [lintningsregler](https://www.npmjs.com/package/eslint-plugin-wdio) f칬r att s칛kerst칛lla att n친gra av de b칛sta metoderna alltid till칛mpas.

## Anv칛nd inte pause

Det kan vara frestande att anv칛nda pause-kommandot, men att anv칛nda detta 칛r en d친lig id칠 eftersom det inte 칛r robust och endast kommer att orsaka instabila tester i det l친nga loppet.

```js
// 游녩
await nameInput.setValue('Bob')
await browser.pause(200) // wait for submit button to enable
await submitFormButton.click()

// 游녨
await nameInput.setValue('Bob')
await submitFormButton.waitForEnabled()
await submitFormButton.click()
```

## Asynkrona loopar

N칛r du har asynkron kod som du vill upprepa 칛r det viktigt att veta att inte alla loopar kan g칬ra detta.
Till exempel till친ter inte Array's forEach-funktion asynkrona callbacks, vilket kan l칛sas p친 [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).

__Obs:__ Du kan fortfarande anv칛nda dessa n칛r du inte beh칬ver att operationen ska vara synkron, som visas i detta exempel `console.log(await $$('h1').map((h1) => h1.getText()))`.

Nedan finns n친gra exempel p친 vad detta inneb칛r.

F칬ljande kommer inte att fungera eftersom asynkrona callbacks inte st칬ds.

```js
// 游녩
const characters = 'this is some example text that should be put in order'
characters.forEach(async (character) => {
    await browser.keys(character)
})
```

F칬ljande kommer att fungera.

```js
// 游녨
const characters = 'this is some example text that should be put in order'
for (const character of characters) {
    await browser.keys(character)
}
```

## H친ll det enkelt

Ibland ser vi att v친ra anv칛ndare mappar data som text eller v칛rden. Detta beh칬vs ofta inte och 칛r ofta ett tecken p친 d친lig kod, kolla exemplen nedan varf칬r det 칛r fallet.

```js
// 游녩 f칬r komplext, synkron bekr칛ftelse, anv칛nd de inbyggda bekr칛ftelserna f칬r att f칬rhindra instabila tester
const headerText = ['Products', 'Prices']
const texts = await $$('th').map(e => e.getText());
expect(texts).toBe(headerText)

// 游녩 f칬r komplext
const headerText = ['Products', 'Prices']
const columns = await $$('th');
await expect(columns).toBeElementsArrayOfSize(2);
for (let i = 0; i < columns.length; i++) {
    await expect(columns[i]).toHaveText(headerText[i]);
}

// 游녩 hittar element genom deras text men tar inte h칛nsyn till elementens position
await expect($('th=Products')).toExist();
await expect($('th=Prices')).toExist();
```

```js
// 游녨 anv칛nd unika identifierare (anv칛nds ofta f칬r anpassade element)
await expect($('[data-testid="Products"]')).toHaveText('Products');
// 游녨 tillg칛nglighetsnamn (anv칛nds ofta f칬r nativa html-element)
await expect($('aria/Product Prices')).toHaveText('Prices');
```

En annan sak vi ibland ser 칛r att enkla saker har en 칬verkomplicerad l칬sning.

```js
// 游녩
class BadExample {
    public async selectOptionByValue(value: string) {
        await $('select').click();
        await $$('option')
            .map(async function (element) {
                const hasValue = (await element.getValue()) === value;
                if (hasValue) {
                    await $(element).click();
                }
                return hasValue;
            });
    }

    public async selectOptionByText(text: string) {
        await $('select').click();
        await $$('option')
            .map(async function (element) {
                const hasText = (await element.getText()) === text;
                if (hasText) {
                    await $(element).click();
                }
                return hasText;
            });
    }
}
```

```js
// 游녨
class BetterExample {
    public async selectOptionByValue(value: string) {
        await $('select').click();
        await $(`option[value=${value}]`).click();
    }

    public async selectOptionByText(text: string) {
        await $('select').click();
        await $(`option=${text}]`).click();
    }
}
```

## Exekvera kod parallellt

Om du inte bryr dig om i vilken ordning viss kod k칬rs kan du anv칛nda [`Promise.all`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all) f칬r att snabba upp exekveringen.

__Obs:__ Eftersom detta g칬r koden sv친rare att l칛sa kan du abstrahera bort detta med hj칛lp av ett sidobjekt eller en funktion, 칛ven om du ocks친 b칬r fr친ga dig om f칬rdelen med prestanda 칛r v칛rd kostnaden f칬r l칛sbarhet.

```js
// 游녩
await name.setValue('Bob')
await email.setValue('bob@webdriver.io')
await age.setValue('50')
await submitFormButton.waitForEnabled()
await submitFormButton.click()

// 游녨
await Promise.all([
    name.setValue('Bob'),
    email.setValue('bob@webdriver.io'),
    age.setValue('50'),
])
await submitFormButton.waitForEnabled()
await submitFormButton.click()
```

Om det 칛r abstraherat kan det se ut ungef칛r som nedan d칛r logiken l칛ggs i en metod som kallas submitWithDataOf och data h칛mtas av Person-klassen.

```js
// 游녨
await form.submitData(new Person('bob@webdriver.io'))
```