---
id: mobile
title: Мобильные команды
---

# Введение в пользовательские и расширенные мобильные команды в WebdriverIO

Тестирование мобильных приложений и мобильных веб-приложений имеет свои собственные проблемы, особенно когда речь идет о специфических различиях между платформами Android и iOS. Хотя Appium предоставляет гибкость для работы с этими различиями, часто требуется глубокое погружение в сложную, зависящую от платформы документацию ([Android](https://github.com/appium/appium-uiautomator2-driver/blob/master/docs/android-mobile-gestures.md), [iOS](https://appium.github.io/appium-xcuitest-driver/latest/reference/execute-methods/)) и команды. Это может сделать написание тестовых скриптов более трудоемким, подверженным ошибкам и сложным для поддержки.

Чтобы упростить этот процесс, WebdriverIO представляет **пользовательские и расширенные мобильные команды**, специально разработанные для тестирования мобильных веб-приложений и нативных приложений. Эти команды абстрагируют сложности базовых API Appium, позволяя писать лаконичные, интуитивно понятные и независимые от платформы тестовые скрипты. Сосредоточившись на простоте использования, мы стремимся уменьшить дополнительную нагрузку при разработке скриптов Appium и дать вам возможность без усилий автоматизировать мобильные приложения.

<LiteYouTubeEmbed
    id="tN0LmKgWjPw"
    title="WebdriverIO Tutorials - Enhanced Mobile Commands"
/>

## Почему пользовательские мобильные команды?

### 1. **Упрощение сложных API**
Некоторые команды Appium, такие как жесты или взаимодействия с элементами, требуют подробного и сложного синтаксиса. Например, выполнение действия долгого нажатия с использованием нативного API Appium требует ручного построения цепочки `action`:

```ts
const element = $('~Contacts')

await browser
    .action( 'pointer', { parameters: { pointerType: 'touch' } })
    .move({ origin: element })
    .down()
    .pause(1500)
    .up()
    .perform()
```

С пользовательскими командами WebdriverIO то же самое действие можно выполнить с помощью одной выразительной строки кода:

```ts
await $('~Contacts').longPress();
```

Это значительно уменьшает шаблонный код, делая ваши скрипты чище и понятнее.

### 2. **Кросс-платформенная абстракция**
Мобильные приложения часто требуют специфической обработки для разных платформ. Например, прокрутка в нативных приложениях значительно отличается между [Android](https://github.com/appium/appium-uiautomator2-driver/blob/master/docs/android-mobile-gestures.md#mobile-scrollgesture) и [iOS](https://appium.github.io/appium-xcuitest-driver/latest/reference/execute-methods/#mobile-scroll). WebdriverIO решает эту проблему, предоставляя унифицированные команды, такие как `scrollIntoView()`, которые бесшовно работают на всех платформах, независимо от базовой реализации.

```ts
await $('~element').scrollIntoView();
```

Такая абстракция обеспечивает переносимость ваших тестов и не требует постоянного ветвления или условной логики для учета различий между операционными системами.

### 3. **Повышенная продуктивность**
Снижая необходимость понимать и внедрять низкоуровневые команды Appium, мобильные команды WebdriverIO позволяют сосредоточиться на тестировании функциональности вашего приложения, а не на борьбе с особенностями платформ. Это особенно полезно для команд с ограниченным опытом в мобильной автоматизации или тех, кто стремится ускорить цикл разработки.

### 4. **Согласованность и удобство обслуживания**
Пользовательские команды обеспечивают единообразие в ваших тестовых скриптах. Вместо различных реализаций для аналогичных действий, ваша команда может опираться на стандартизированные, многократно используемые команды. Это не только делает кодовую базу более обслуживаемой, но и снижает барьер для адаптации новых членов команды.

## Почему улучшать определенные мобильные команды?

### 1. Добавление гибкости
Некоторые мобильные команды улучшены для предоставления дополнительных опций и параметров, которые недоступны в стандартных API Appium. Например, WebdriverIO добавляет логику повторных попыток, таймауты и возможность фильтровать вебвью по определенным критериям, обеспечивая больший контроль в сложных сценариях.

```ts
// Пример: Настройка интервалов повторных попыток и таймаутов для обнаружения вебвью
await driver.getContexts({
  returnDetailedContexts: true,
  androidWebviewConnectionRetryTime: 1000, // Повторять каждую секунду
  androidWebviewConnectTimeout: 10000,    // Таймаут через 10 секунд
});
```

Эти опции помогают адаптировать скрипты автоматизации к динамическому поведению приложения без дополнительного шаблонного кода.

### 2. Улучшение удобства использования
Расширенные команды абстрагируют сложности и повторяющиеся шаблоны, встречающиеся в нативных API. Они позволяют выполнять больше действий с меньшим количеством строк кода, уменьшая кривую обучения для новых пользователей и делая скрипты более читаемыми и удобными в обслуживании.

```ts
// Пример: Расширенная команда для переключения контекста по заголовку
await driver.switchContext({
  title: 'My Webview Title',
});
```

По сравнению со стандартными методами Appium, расширенные команды устраняют необходимость в дополнительных шагах, таких как ручное получение доступных контекстов и их фильтрация.

### 3. Стандартизация поведения
WebdriverIO гарантирует, что расширенные команды ведут себя согласованно на таких платформах, как Android и iOS. Эта кросс-платформенная абстракция минимизирует необходимость условного ветвления логики в зависимости от операционной системы, что приводит к более удобным для обслуживания тестовым скриптам.

```ts
// Пример: Унифицированная команда прокрутки для обеих платформ
await $('~element').scrollIntoView();
```

Эта стандартизация упрощает кодовые базы, особенно для команд, автоматизирующих тесты на нескольких платформах.

### 4. Повышение надежности
Включая механизмы повторных попыток, умные значения по умолчанию и подробные сообщения об ошибках, расширенные команды снижают вероятность нестабильных тестов. Эти улучшения обеспечивают устойчивость ваших тестов к таким проблемам, как задержки в инициализации вебвью или переходные состояния приложения.

```ts
// Пример: Расширенное переключение вебвью с надежной логикой соответствия
await driver.switchContext({
  url: /.*my-app\/dashboard/,
  androidWebviewConnectionRetryTime: 500,
  androidWebviewConnectTimeout: 7000,
});
```

Это делает выполнение тестов более предсказуемым и менее подверженным сбоям, вызванным факторами окружения.

### 5. Расширение возможностей отладки
Расширенные команды часто возвращают более богатые метаданные, облегчая отладку сложных сценариев, особенно в гибридных приложениях. Например, команды типа getContext и getContexts могут возвращать подробную информацию о вебвью, включая заголовок, URL и статус видимости.

```ts
// Пример: Получение подробных метаданных для отладки
const contexts = await driver.getContexts({ returnDetailedContexts: true });
console.log(contexts);
```

Эти метаданные помогают быстрее определять и решать проблемы, улучшая общий опыт отладки.


Улучшая мобильные команды, WebdriverIO не только упрощает автоматизацию, но и соответствует своей миссии предоставлять разработчикам инструменты, которые являются мощными, надежными и интуитивно понятными в использовании.

---

## Гибридные приложения

Гибридные приложения объединяют веб-контент с нативной функциональностью и требуют специализированной обработки во время автоматизации. Эти приложения используют вебвью для отображения веб-контента внутри нативного приложения. WebdriverIO предоставляет расширенные методы для эффективной работы с гибридными приложениями.

### Понимание вебвью
Вебвью — это компонент, подобный браузеру, встроенный в нативное приложение:

- **Android:** Вебвью основаны на Chrome/System Webview и могут содержать несколько страниц (подобно вкладкам браузера). Эти вебвью требуют ChromeDriver для автоматизации взаимодействий. Appium может автоматически определить требуемую версию ChromeDriver на основе версии System WebView или Chrome, установленных на устройстве, и загрузить её автоматически, если она ещё не доступна. Этот подход обеспечивает бесшовную совместимость и минимизирует ручную настройку. Обратитесь к [документации Appium UIAutomator2](https://github.com/appium/appium-uiautomator2-driver?tab=readme-ov-file#automatic-discovery-of-compatible-chromedriver), чтобы узнать, как Appium автоматически загружает правильную версию ChromeDriver.
- **iOS:** Вебвью работают на Safari (WebKit) и идентифицируются общими идентификаторами, такими как `WEBVIEW_{id}`.

### Проблемы с гибридными приложениями
1. Идентификация правильного вебвью среди нескольких вариантов.
2. Получение дополнительных метаданных, таких как заголовок, URL или имя пакета для лучшего контекста.
3. Обработка специфических различий между платформами Android и iOS.
4. Надежное переключение на правильный контекст в гибридном приложении.

### Ключевые команды для гибридных приложений

#### 1. `getContext`
Получает текущий контекст сессии. По умолчанию ведет себя как метод getContext Appium, но может предоставлять подробную информацию о контексте при включении `returnDetailedContext`. Для получения дополнительной информации см. [`getContext`](/docs/api/mobile/getContext)

#### 2. `getContexts`
Возвращает подробный список доступных контекстов, улучшая метод contexts Appium. Это упрощает определение правильного вебвью для взаимодействия без вызова дополнительных команд для определения заголовка, URL или активного `bundleId|packageName`. Для получения дополнительной информации см. [`getContexts`](/docs/api/mobile/getContexts)

#### 3. `switchContext`
Переключается на определенное вебвью на основе имени, заголовка или URL. Предоставляет дополнительную гибкость, такую как использование регулярных выражений для сопоставления. Для получения дополнительной информации см. [`switchContext`](/docs/api/mobile/switchContext)

### Ключевые особенности для гибридных приложений
1. Подробные метаданные: Получение всесторонних деталей для отладки и надежного переключения контекста.
2. Кросс-платформенная согласованность: Унифицированное поведение для Android и iOS, безупречная обработка особенностей платформ.
3. Настраиваемая логика повторных попыток (Android): Регулировка интервалов повторных попыток и таймаутов для обнаружения вебвью.


:::info Примечания и ограничения
- Android предоставляет дополнительные метаданные, такие как `packageName` и `webviewPageId`, в то время как iOS фокусируется на `bundleId`.
- Логика повторных попыток настраивается для Android, но не применима к iOS.
- Существует несколько случаев, когда iOS не может найти вебвью. Appium предоставляет различные дополнительные возможности для `appium-xcuitest-driver` для поиска вебвью. Если вы считаете, что вебвью не найдено, вы можете попробовать установить одну из следующих возможностей:
    - `appium:includeSafariInWebviews`: Добавляет веб-контексты Safari в список контекстов, доступных во время теста нативного/вебвью приложения. Это полезно, если тест открывает Safari и нуждается в возможности взаимодействия с ним. По умолчанию `false`.
    - `appium:webviewConnectRetries`: Максимальное количество повторных попыток перед отказом от обнаружения страниц вебвью. Задержка между каждой попыткой составляет 500 мс, по умолчанию - `10` попыток.
    - `appium:webviewConnectTimeout`: Максимальное количество времени в миллисекундах для ожидания обнаружения страницы вебвью. По умолчанию - `5000` мс.

Для продвинутых примеров и деталей см. документацию API мобильных устройств WebdriverIO.
:::


---

Наш растущий набор команд отражает наше стремление сделать мобильную автоматизацию доступной и элегантной. Будь то выполнение сложных жестов или работа с элементами нативного приложения, эти команды соответствуют философии WebdriverIO по созданию бесшовного опыта автоматизации. И мы не останавливаемся на достигнутом — если есть функция, которую вы хотели бы видеть, мы приветствуем ваши отзывы. Не стесняйтесь отправлять свои запросы через [эту ссылку](https://github.com/webdriverio/webdriverio/issues/new/choose).