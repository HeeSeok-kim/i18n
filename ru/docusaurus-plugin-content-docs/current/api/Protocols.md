---
id: protocols
title: Команды протокола
---

WebdriverIO - это фреймворк для автоматизации, который использует различные протоколы автоматизации для управления удаленным агентом, например, браузером, мобильным устройством или телевизором. В зависимости от удаленного устройства применяются разные протоколы. Эти команды назначаются объектам [Browser](/docs/api/browser) или [Element](/docs/api/element) в зависимости от информации о сессии, предоставляемой удаленным сервером (например, драйвером браузера).

Внутренне WebdriverIO использует команды протокола почти для всех взаимодействий с удаленным агентом. Однако дополнительные команды, назначенные объектам [Browser](/docs/api/browser) или [Element](/docs/api/element), упрощают использование WebdriverIO. Например, получение текста элемента с использованием команд протокола выглядело бы так:

```js
const searchInput = await browser.findElement('css selector', '#lst-ib')
await client.getElementText(searchInput['element-6066-11e4-a52e-4f735466cecf'])
```

Используя удобные команды объектов [Browser](/docs/api/browser) или [Element](/docs/api/element), это можно сократить до:

```js
$('#lst-ib').getText()
```

В следующем разделе объясняется каждый отдельный протокол.

## Протокол WebDriver

[WebDriver](https://w3c.github.io/webdriver/#elements) - это веб-стандарт для автоматизации браузера. В отличие от некоторых других инструментов E2E, он гарантирует, что автоматизация может быть выполнена на реальных браузерах, которые используют ваши пользователи, например, Firefox, Safari и Chrome, а также на браузерах на основе Chromium, таких как Edge, а не только на браузерных движках, например, WebKit, которые сильно отличаются.

Преимущество использования протокола WebDriver в отличие от отладочных протоколов, таких как [Chrome DevTools](https://w3c.github.io/webdriver/#elements), заключается в том, что у вас есть определенный набор команд, которые позволяют взаимодействовать с браузером одинаково во всех браузерах, что снижает вероятность нестабильности. Кроме того, этот протокол предлагает возможности для массовой масштабируемости путем использования облачных поставщиков, таких как [Sauce Labs](https://saucelabs.com/), [BrowserStack](https://www.browserstack.com/) и [другие](https://github.com/christian-bromann/awesome-selenium#cloud-services).

## Протокол WebDriver Bidi

Протокол [WebDriver Bidi](https://w3c.github.io/webdriver-bidi/) - это второе поколение протокола, над которым в настоящее время работают большинство поставщиков браузеров. По сравнению с его предшественником, протокол поддерживает двунаправленную связь (отсюда и "Bidi") между фреймворком и удаленным устройством. Кроме того, он вводит дополнительные примитивы для лучшего анализа браузера, чтобы лучше автоматизировать современные веб-приложения в браузере.

Поскольку этот протокол в настоящее время находится в разработке, со временем будет добавлено больше функций, поддерживаемых браузерами. Если вы используете удобные команды WebdriverIO, для вас ничего не изменится. WebdriverIO будет использовать эти новые возможности протокола, как только они станут доступны и поддерживаемы в браузере.

## Appium

Проект [Appium](https://appium.io/) предоставляет возможности для автоматизации мобильных, настольных и всех других видов IoT-устройств. В то время как WebDriver фокусируется на браузере и веб, видение Appium заключается в использовании того же подхода, но для любого произвольного устройства. В дополнение к командам, которые определяет WebDriver, у него есть специальные команды, которые часто специфичны для удаленного устройства, которое автоматизируется. Для сценариев мобильного тестирования это идеально, когда вы хотите писать и запускать одни и те же тесты как для приложений Android, так и для iOS.

Согласно [документации](https://appium.github.io/appium.io/docs/en/about-appium/intro/?lang=en) Appium, он был разработан для удовлетворения потребностей мобильной автоматизации в соответствии с философией, изложенной в следующих четырех принципах:

- Вам не должно быть нужно перекомпилировать ваше приложение или изменять его каким-либо образом, чтобы автоматизировать его.
- Вы не должны быть привязаны к определенному языку или фреймворку для написания и запуска тестов.
- Фреймворк мобильной автоматизации не должен изобретать велосипед, когда дело касается API автоматизации.
- Фреймворк мобильной автоматизации должен быть с открытым исходным кодом, по духу и на практике, а также по названию!

## Chromium

Протокол Chromium предлагает расширенный набор команд поверх протокола WebDriver, который поддерживается только при запуске автоматизированных сессий через [Chromedriver](https://chromedriver.chromium.org/chromedriver-canary) или [Edgedriver](https://developer.microsoft.com/fr-fr/microsoft-edge/tools/webdriver).

## Firefox

Протокол Firefox предлагает расширенный набор команд поверх протокола WebDriver, который поддерживается только при запуске автоматизированных сессий через [Geckodriver](https://github.com/mozilla/geckodriver).

## Sauce Labs

Протокол [Sauce Labs](https://saucelabs.com/) предлагает расширенный набор команд поверх протокола WebDriver, который поддерживается только при запуске автоматизированных сессий с использованием облака Sauce Labs.

## Selenium Standalone

Протокол [Selenium Standalone](https://www.selenium.dev/documentation/grid/advanced_features/endpoints/) предлагает расширенный набор команд поверх протокола WebDriver, который поддерживается только при запуске автоматизированных сессий с использованием Selenium Grid.

## JSON Wire Protocol

[JSON Wire Protocol](https://www.selenium.dev/documentation/legacy/json_wire_protocol/) является предшественником протокола WebDriver и сегодня __устарел__. Хотя некоторые команды могут все еще поддерживаться в определенных средах, не рекомендуется использовать какие-либо его команды.

## Mobile JSON Wire Protocol

[Mobile JSON Wire Protocol](https://github.com/SeleniumHQ/mobile-spec/blob/master/spec-draft.md) - это расширенный набор мобильных команд поверх JSON Wire Protocol. Учитывая, что последний устарел, Mobile JSON Wire Protocol также __устарел__. Appium может все еще поддерживать некоторые его команды, но их использование не рекомендуется.