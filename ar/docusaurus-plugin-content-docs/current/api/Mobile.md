---
id: mobile
title: أوامر الجوال
---

# مقدمة لأوامر الجوال المخصصة والمحسنة في WebdriverIO

يأتي اختبار تطبيقات الجوال وتطبيقات الويب المحمولة بتحدياته الخاصة، خاصة عند التعامل مع الاختلافات المحددة للمنصات بين Android وiOS. في حين أن Appium يوفر المرونة للتعامل مع هذه الاختلافات، فإنه غالبًا ما يتطلب منك التعمق في وثائق معقدة تعتمد على المنصة ([Android](https://github.com/appium/appium-uiautomator2-driver/blob/master/docs/android-mobile-gestures.md)، [iOS](https://appium.github.io/appium-xcuitest-driver/latest/reference/execute-methods/)) وأوامر. يمكن أن يجعل هذا كتابة نصوص الاختبار أكثر استهلاكًا للوقت وعرضة للأخطاء وصعبة الصيانة.

لتبسيط العملية، يقدم WebdriverIO **أوامر جوال مخصصة ومحسنة** مصممة خصيصًا لاختبار الويب المحمول وتطبيقات الجوال الأصلية. تقوم هذه الأوامر بتجريد تعقيدات واجهات برمجة التطبيقات الأساسية في Appium، مما يتيح لك كتابة نصوص اختبار موجزة وبديهية ومستقلة عن المنصة. من خلال التركيز على سهولة الاستخدام، نهدف إلى تقليل العبء الإضافي أثناء تطوير نصوص Appium وتمكينك من أتمتة تطبيقات الجوال بسهولة.

<LiteYouTubeEmbed
    id="tN0LmKgWjPw"
    title="WebdriverIO Tutorials - Enhanced Mobile Commands"
/>

## لماذا أوامر الجوال المخصصة؟

### 1. **تبسيط واجهات البرمجة المعقدة**
بعض أوامر Appium، مثل الإيماءات أو تفاعلات العناصر، تتضمن بناء جمل مطول ومعقد. على سبيل المثال، تنفيذ إجراء الضغط الطويل باستخدام واجهة برمجة تطبيقات Appium الأصلية يتطلب بناء سلسلة `action` يدويًا:

```ts
const element = $('~Contacts')

await browser
    .action( 'pointer', { parameters: { pointerType: 'touch' } })
    .move({ origin: element })
    .down()
    .pause(1500)
    .up()
    .perform()
```

باستخدام أوامر WebdriverIO المخصصة، يمكن تنفيذ الإجراء نفسه بسطر واحد تعبيري من التعليمات البرمجية:

```ts
await $('~Contacts').longPress();
```

هذا يقلل بشكل كبير من التعليمات البرمجية المتكررة، مما يجعل نصوصك أنظف وأسهل في الفهم.

### 2. **تجريد عبر المنصات**
غالبًا ما تتطلب تطبيقات الجوال معالجة محددة للمنصة. على سبيل المثال، التمرير في التطبيقات الأصلية يختلف بشكل كبير بين [Android](https://github.com/appium/appium-uiautomator2-driver/blob/master/docs/android-mobile-gestures.md#mobile-scrollgesture) و[iOS](https://appium.github.io/appium-xcuitest-driver/latest/reference/execute-methods/#mobile-scroll). يسد WebdriverIO هذه الفجوة بتوفير أوامر موحدة مثل `scrollIntoView()` التي تعمل بسلاسة عبر المنصات، بغض النظر عن التنفيذ الأساسي.

```ts
await $('~element').scrollIntoView();
```

يضمن هذا التجريد أن اختباراتك قابلة للنقل ولا تتطلب تفرعات مستمرة أو منطق شرطي لمراعاة اختلافات نظام التشغيل.

### 3. **زيادة الإنتاجية**
من خلال تقليل الحاجة إلى فهم وتنفيذ أوامر Appium منخفضة المستوى، تمكنك أوامر الجوال من WebdriverIO من التركيز على اختبار وظائف تطبيقك بدلاً من التعامل مع الفروق الدقيقة الخاصة بالمنصة. هذا مفيد بشكل خاص للفرق ذات الخبرة المحدودة في أتمتة الجوال أو تلك التي تسعى إلى تسريع دورة التطوير الخاصة بهم.

### 4. **الاتساق وقابلية الصيانة**
تجلب الأوامر المخصصة التوحيد لنصوص الاختبار الخاصة بك. بدلاً من وجود تنفيذات متفاوتة لإجراءات مماثلة، يمكن لفريقك الاعتماد على أوامر قياسية قابلة لإعادة الاستخدام. هذا لا يجعل قاعدة التعليمات البرمجية أكثر قابلية للصيانة فحسب، بل يقلل أيضًا من العقبات في تأهيل أعضاء الفريق الجدد.

## لماذا تحسين بعض أوامر الجوال؟

### 1. إضافة المرونة
يتم تحسين بعض أوامر الجوال لتوفير خيارات ومعلمات إضافية غير متوفرة في واجهات برمجة تطبيقات Appium الافتراضية. على سبيل المثال، يضيف WebdriverIO منطق إعادة المحاولة والمهلات والقدرة على تصفية العروض الويب حسب معايير محددة، مما يتيح المزيد من التحكم في السيناريوهات المعقدة.

```ts
// مثال: تخصيص فترات إعادة المحاولة والمهلات للكشف عن webview
await driver.getContexts({
  returnDetailedContexts: true,
  androidWebviewConnectionRetryTime: 1000, // إعادة المحاولة كل 1 ثانية
  androidWebviewConnectTimeout: 10000,    // المهلة بعد 10 ثوانٍ
});
```

تساعد هذه الخيارات في تكييف نصوص الأتمتة مع سلوك التطبيق الديناميكي دون كود متكرر إضافي.

### 2. تحسين قابلية الاستخدام
تجرد الأوامر المحسنة التعقيدات والأنماط المتكررة الموجودة في واجهات البرمجة الأصلية. وهي تسمح لك بتنفيذ المزيد من الإجراءات باستخدام عدد أقل من الأسطر، مما يقلل من منحنى التعلم للمستخدمين الجدد ويجعل النصوص أسهل للقراءة والصيانة.

```ts
// مثال: أمر محسن لتبديل السياق حسب العنوان
await driver.switchContext({
  title: 'My Webview Title',
});
```

مقارنة بطرق Appium الافتراضية، تلغي الأوامر المحسنة الحاجة إلى خطوات إضافية مثل استرداد السياقات المتاحة يدويًا وتصفيتها.

### 3. توحيد السلوك
يضمن WebdriverIO أن تتصرف الأوامر المحسنة بشكل متسق عبر منصات مثل Android وiOS. هذا التجريد عبر المنصات يقلل من الحاجة إلى منطق التفرع المشروط استنادًا إلى نظام التشغيل، مما يؤدي إلى نصوص اختبار أكثر قابلية للصيانة.

```ts
// مثال: أمر تمرير موحد لكلا المنصتين
await $('~element').scrollIntoView();
```

يبسط هذا التوحيد قواعد التعليمات البرمجية، خاصة بالنسبة للفرق التي تقوم بأتمتة الاختبارات على منصات متعددة.

### 4. زيادة الموثوقية
من خلال دمج آليات إعادة المحاولة والإعدادات الافتراضية الذكية ورسائل الخطأ المفصلة، تقلل الأوامر المحسنة من احتمالية حدوث اختبارات غير مستقرة. تضمن هذه التحسينات أن تكون اختباراتك مرنة لمشكلات مثل التأخير في تهيئة webview أو حالات التطبيق العابرة.

```ts
// مثال: تبديل webview محسن مع منطق مطابقة قوي
await driver.switchContext({
  url: /.*my-app\/dashboard/,
  androidWebviewConnectionRetryTime: 500,
  androidWebviewConnectTimeout: 7000,
});
```

هذا يجعل تنفيذ الاختبار أكثر قابلية للتنبؤ وأقل عرضة للإخفاقات الناجمة عن العوامل البيئية.

### 5. تعزيز قدرات التصحيح
غالبًا ما ترجع الأوامر المحسنة بيانات وصفية أغنى، مما يتيح تصحيح أسهل للسيناريوهات المعقدة، خاصة في التطبيقات الهجينة. على سبيل المثال، يمكن لأوامر مثل getContext وgetContexts إرجاع معلومات مفصلة حول webviews، بما في ذلك العنوان وعنوان URL وحالة الرؤية.

```ts
// مثال: استرداد بيانات وصفية مفصلة للتصحيح
const contexts = await driver.getContexts({ returnDetailedContexts: true });
console.log(contexts);
```

تساعد هذه البيانات الوصفية في تحديد المشكلات وحلها بشكل أسرع، مما يحسن تجربة التصحيح بشكل عام.


من خلال تحسين أوامر الجوال، لا يجعل WebdriverIO الأتمتة أسهل فحسب، بل يتماشى أيضًا مع مهمته لتزويد المطورين بأدوات قوية وموثوقة وسهلة الاستخدام.

---

## التطبيقات الهجينة

تجمع التطبيقات الهجينة بين محتوى الويب والوظائف الأصلية وتتطلب معالجة متخصصة أثناء الأتمتة. تستخدم هذه التطبيقات webviews لعرض محتوى الويب داخل تطبيق أصلي. يوفر WebdriverIO طرقًا محسنة للعمل مع التطبيقات الهجينة بشكل فعال.

### فهم Webviews
Webview هو مكون شبيه بالمتصفح مدمج في تطبيق أصلي:

- **Android:** تستند Webviews إلى Chrome/System Webview وقد تحتوي على صفحات متعددة (مشابهة لعلامات تبويب المتصفح). تتطلب هذه الـwebviews استخدام ChromeDriver لأتمتة التفاعلات. يمكن لـAppium تحديد إصدار ChromeDriver المطلوب تلقائيًا بناءً على إصدار System WebView أو Chrome المثبت على الجهاز وتنزيله تلقائيًا إذا لم يكن متاحًا بالفعل. يضمن هذا النهج التوافق السلس ويقلل الإعداد اليدوي. راجع [وثائق Appium UIAutomator2](https://github.com/appium/appium-uiautomator2-driver?tab=readme-ov-file#automatic-discovery-of-compatible-chromedriver) لمعرفة كيفية تنزيل Appium تلقائيًا لإصدار ChromeDriver الصحيح.
- **iOS:** تعمل Webviews بواسطة Safari (WebKit) ويتم تحديدها بواسطة معرفات عامة مثل `WEBVIEW_{id}`.

### تحديات التطبيقات الهجينة
1. تحديد webview الصحيح من بين خيارات متعددة.
2. استرداد بيانات وصفية إضافية مثل العنوان أو URL أو اسم الحزمة للحصول على سياق أفضل.
3. التعامل مع الاختلافات الخاصة بالمنصة بين Android وiOS.
4. التبديل إلى السياق الصحيح في تطبيق هجين بشكل موثوق.

### الأوامر الرئيسية للتطبيقات الهجينة

#### 1. `getContext`
يسترجع السياق الحالي للجلسة. بشكل افتراضي، يتصرف مثل طريقة getContext في Appium ولكن يمكنه توفير معلومات سياق مفصلة عند تمكين `returnDetailedContext`. لمزيد من المعلومات انظر [`getContext`](/docs/api/mobile/getContext)

#### 2. `getContexts`
يعيد قائمة مفصلة بالسياقات المتاحة، مما يحسن طريقة contexts في Appium. هذا يجعل من السهل تحديد webview الصحيح للتفاعل دون الحاجة لاستدعاء أوامر إضافية لتحديد العنوان أو URL أو `bundleId|packageName` النشط. لمزيد من المعلومات انظر [`getContexts`](/docs/api/mobile/getContexts)

#### 3. `switchContext`
ينتقل إلى webview محدد بناءً على الاسم أو العنوان أو URL. يوفر مرونة إضافية، مثل استخدام التعبيرات النمطية للمطابقة. لمزيد من المعلومات انظر [`switchContext`](/docs/api/mobile/switchContext)

### الميزات الرئيسية للتطبيقات الهجينة
1. البيانات الوصفية المفصلة: استرجاع تفاصيل شاملة للتصحيح وتبديل السياق الموثوق.
2. الاتساق عبر المنصات: سلوك موحد لنظامي Android وiOS، مع التعامل مع خصائص المنصات بسلاسة.
3. منطق إعادة المحاولة المخصص (Android): ضبط فترات إعادة المحاولة والمهلات للكشف عن webview.


:::info ملاحظات وقيود
- يوفر Android بيانات وصفية إضافية، مثل `packageName` و`webviewPageId`، بينما يركز iOS على `bundleId`.
- منطق إعادة المحاولة قابل للتخصيص لنظام Android ولكنه لا ينطبق على iOS.
- هناك عدة حالات لا يمكن فيها لنظام iOS العثور على Webview. يوفر Appium إمكانات إضافية مختلفة لـ `appium-xcuitest-driver` للعثور على Webview. إذا كنت تعتقد أن Webview لم يتم العثور عليه، يمكنك تجربة تعيين إحدى الإمكانات التالية:
    - `appium:includeSafariInWebviews`: إضافة سياقات الويب Safari إلى قائمة السياقات المتاحة أثناء اختبار التطبيق الأصلي/webview. هذا مفيد إذا كان الاختبار يفتح Safari ويحتاج إلى التفاعل معه. الإعداد الافتراضي هو `false`.
    - `appium:webviewConnectRetries`: الحد الأقصى لعدد إعادة المحاولات قبل التخلي عن اكتشاف صفحات webview. التأخير بين كل إعادة محاولة هو 500 مللي ثانية، والإعداد الافتراضي هو `10` محاولات.
    - `appium:webviewConnectTimeout`: الحد الأقصى للوقت بالمللي ثانية للانتظار حتى يتم اكتشاف صفحة webview. الإعداد الافتراضي هو `5000` مللي ثانية.

لأمثلة متقدمة وتفاصيل، راجع وثائق واجهة برمجة تطبيقات WebdriverIO للجوال.
:::


---

تعكس مجموعتنا المتنامية من الأوامر التزامنا بجعل أتمتة الجوال في متناول الجميع وأنيقة. سواء كنت تقوم بإيماءات معقدة أو تعمل مع عناصر التطبيق الأصلية، تتماشى هذه الأوامر مع فلسفة WebdriverIO لخلق تجربة أتمتة سلسة. ولا نتوقف عند هذا الحد - إذا كانت هناك ميزة ترغب في رؤيتها، نرحب بملاحظاتك. لا تتردد في تقديم طلباتك عبر [هذا الرابط](https://github.com/webdriverio/webdriverio/issues/new/choose).