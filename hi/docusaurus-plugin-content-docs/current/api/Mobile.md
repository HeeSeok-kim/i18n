---
id: mobile
title: मोबाइल कमांड्स
---

# WebdriverIO में कस्टम और एन्हांस्ड मोबाइल कमांड्स का परिचय

मोबाइल ऐप्स और मोबाइल वेब एप्लिकेशन का परीक्षण अपनी खुद की चुनौतियों के साथ आता है, विशेष रूप से Android और iOS के बीच प्लेटफॉर्म-विशिष्ट अंतरों से निपटते समय। जबकि Appium इन अंतरों को संभालने के लिए लचीलापन प्रदान करता है, अक्सर आपको जटिल, प्लेटफॉर्म-निर्भर दस्तावेजों ([Android](https://github.com/appium/appium-uiautomator2-driver/blob/master/docs/android-mobile-gestures.md), [iOS](https://appium.github.io/appium-xcuitest-driver/latest/reference/execute-methods/)) और कमांड्स में गहराई से जाना पड़ता है। यह टेस्ट स्क्रिप्ट लिखने को अधिक समय खपाने वाला, त्रुटि-प्रवण और बनाए रखने में कठिन बना सकता है।

प्रक्रिया को सरल बनाने के लिए, WebdriverIO मोबाइल वेब और नेटिव ऐप परीक्षण के लिए विशेष रूप से तैयार किए गए **कस्टम और एन्हांस्ड मोबाइल कमांड्स** प्रस्तुत करता है। ये कमांड्स अंतर्निहित Appium APIs की जटिलताओं को सरल बनाते हैं, जिससे आप संक्षिप्त, सहज और प्लेटफॉर्म-अज्ञेयवादी टेस्ट स्क्रिप्ट लिख सकते हैं। उपयोग में आसानी पर ध्यान केंद्रित करके, हम Appium स्क्रिप्ट विकसित करते समय अतिरिक्त भार को कम करने और आपको आसानी से मोबाइल ऐप्स को स्वचालित करने के लिए सशक्त बनाने का लक्ष्य रखते हैं।

<LiteYouTubeEmbed
    id="tN0LmKgWjPw"
    title="WebdriverIO Tutorials - Enhanced Mobile Commands"
/>

## क्यों कस्टम मोबाइल कमांड्स?

### 1. **जटिल APIs को सरल बनाना**
कुछ Appium कमांड्स, जैसे जेस्चर या एलिमेंट इंटरैक्शन, वर्बोस और जटिल सिंटैक्स शामिल करते हैं। उदाहरण के लिए, नेटिव Appium API के साथ लॉन्ग प्रेस एक्शन को निष्पादित करने के लिए मैन्युअल रूप से `action` चेन बनाने की आवश्यकता होती है:

```ts
const element = $('~Contacts')

await browser
    .action( 'pointer', { parameters: { pointerType: 'touch' } })
    .move({ origin: element })
    .down()
    .pause(1500)
    .up()
    .perform()
```

WebdriverIO के कस्टम कमांड्स के साथ, समान क्रिया एक ही अभिव्यंजक पंक्ति कोड के साथ की जा सकती है:

```ts
await $('~Contacts').longPress();
```

यह नाटकीय रूप से बॉयलरप्लेट कोड को कम करता है, आपकी स्क्रिप्ट को स्पष्ट और समझने में आसान बनाता है।

### 2. **क्रॉस-प्लेटफॉर्म अब्स्ट्रैक्शन**
मोबाइल ऐप्स को अक्सर प्लेटफॉर्म-विशिष्ट हैंडलिंग की आवश्यकता होती है। उदाहरण के लिए, नेटिव ऐप्स में स्क्रॉलिंग [Android](https://github.com/appium/appium-uiautomator2-driver/blob/master/docs/android-mobile-gestures.md#mobile-scrollgesture) और [iOS](https://appium.github.io/appium-xcuitest-driver/latest/reference/execute-methods/#mobile-scroll) के बीच काफी भिन्न होती है। WebdriverIO `scrollIntoView()` जैसे एकीकृत कमांड्स प्रदान करके इस अंतर को पाटता है जो अंतर्निहित कार्यान्वयन के बावजूद प्लेटफॉर्म में निर्बाध रूप से काम करते हैं।

```ts
await $('~element').scrollIntoView();
```

यह अब्स्ट्रैक्शन सुनिश्चित करता है कि आपके परीक्षण पोर्टेबल हैं और ओएस अंतरों को ध्यान में रखने के लिए निरंतर ब्रांचिंग या कंडिशनल लॉजिक की आवश्यकता नहीं है।

### 3. **बढ़ी हुई उत्पादकता**
निम्न-स्तरीय Appium कमांड्स को समझने और लागू करने की आवश्यकता को कम करके, WebdriverIO के मोबाइल कमांड्स आपको प्लेटफॉर्म-विशिष्ट बारीकियों से जूझने के बजाय अपने ऐप की कार्यक्षमता का परीक्षण करने पर ध्यान केंद्रित करने में सक्षम बनाते हैं। यह विशेष रूप से मोबाइल ऑटोमेशन में सीमित अनुभव वाली टीमों या अपने विकास चक्र को त्वरित करने की इच्छा रखने वालों के लिए फायदेमंद है।

### 4. **स्थिरता और रखरखाव योग्यता**
कस्टम कमांड्स आपकी टेस्ट स्क्रिप्ट में एकरूपता लाते हैं। समान क्रियाओं के लिए अलग-अलग कार्यान्वयन होने के बजाय, आपकी टीम मानकीकृत, पुन: प्रयोज्य कमांड्स पर भरोसा कर सकती है। यह न केवल कोडबेस को अधिक रखरखाव योग्य बनाता है बल्कि नए टीम सदस्यों को शामिल करने के लिए बाधा को भी कम करता है।

## क्यों कुछ मोबाइल कमांड्स को बेहतर बनाया गया?

### 1. लचीलापन जोड़ना
कुछ मोबाइल कमांड्स को अतिरिक्त विकल्प और पैरामीटर प्रदान करने के लिए बेहतर बनाया गया है जो डिफ़ॉल्ट Appium APIs में उपलब्ध नहीं हैं। उदाहरण के लिए, WebdriverIO रिट्राई लॉजिक, टाइमआउट और विशिष्ट मानदंडों द्वारा वेबव्यू को फ़िल्टर करने की क्षमता जोड़ता है, जो जटिल परिदृश्यों पर अधिक नियंत्रण को सक्षम करता है।

```ts
// Example: Customizing retry intervals and timeouts for webview detection
await driver.getContexts({
  returnDetailedContexts: true,
  androidWebviewConnectionRetryTime: 1000, // Retry every 1 second
  androidWebviewConnectTimeout: 10000,    // Timeout after 10 seconds
});
```

ये विकल्प अतिरिक्त बॉयलरप्लेट कोड के बिना गतिशील ऐप व्यवहार के लिए ऑटोमेशन स्क्रिप्ट को अनुकूलित करने में मदद करते हैं।

### 2. उपयोगिता में सुधार
एन्हांस्ड कमांड्स नेटिव APIs में पाई जाने वाली जटिलताओं और दोहराव पैटर्न को सरल बनाते हैं। वे आपको कम पंक्तियों के कोड के साथ अधिक क्रियाएँ करने की अनुमति देते हैं, नए उपयोगकर्ताओं के लिए सीखने की कठिनाई को कम करते हैं और स्क्रिप्ट को पढ़ने और बनाए रखने में आसान बनाते हैं।

```ts
// Example: Enhanced command for switching context by title
await driver.switchContext({
  title: 'My Webview Title',
});
```

डिफ़ॉल्ट Appium विधियों की तुलना में, एन्हांस्ड कमांड्स मैन्युअल रूप से उपलब्ध संदर्भों को प्राप्त करने और उनके माध्यम से फ़िल्टरिंग करने जैसे अतिरिक्त चरणों की आवश्यकता को समाप्त करते हैं।

### 3. व्यवहार का मानकीकरण
WebdriverIO सुनिश्चित करता है कि एन्हांस्ड कमांड्स Android और iOS जैसे प्लेटफार्मों में एक समान व्यवहार करें। यह क्रॉस-प्लेटफॉर्म अब्स्ट्रैक्शन ऑपरेटिंग सिस्टम के आधार पर कंडिशनल ब्रांचिंग लॉजिक की आवश्यकता को कम करता है, जिससे अधिक रखरखाव योग्य टेस्ट स्क्रिप्ट बनते हैं।

```ts
// Example: Unified scroll command for both platforms
await $('~element').scrollIntoView();
```

यह मानकीकरण कोडबेस को सरल बनाता है, विशेष रूप से कई प्लेटफार्मों पर स्वचालित परीक्षण करने वाली टीमों के लिए।

### 4. विश्वसनीयता बढ़ाना
रिट्राई मैकेनिज्म, स्मार्ट डिफॉल्ट्स और विस्तृत त्रुटि संदेशों को शामिल करके, एन्हांस्ड कमांड्स अस्थिर परीक्षणों की संभावना को कम करते हैं। ये सुधार सुनिश्चित करते हैं कि आपके परीक्षण वेबव्यू इनिशियलाइजेशन में देरी या अस्थायी ऐप स्थितियों जैसे मुद्दों के प्रति लचीले हैं।

```ts
// Example: Enhanced webview switching with robust matching logic
await driver.switchContext({
  url: /.*my-app\/dashboard/,
  androidWebviewConnectionRetryTime: 500,
  androidWebviewConnectTimeout: 7000,
});
```

यह टेस्ट एक्जिक्यूशन को अधिक अनुमानित और पर्यावरणीय कारकों के कारण होने वाली विफलताओं के प्रति कम प्रवण बनाता है।

### 5. डीबगिंग क्षमताओं को बढ़ाना
एन्हांस्ड कमांड्स अक्सर समृद्ध मेटाडेटा वापस करते हैं, जिससे जटिल परिदृश्यों की आसान डीबगिंग संभव होती है, विशेष रूप से हाइब्रिड ऐप्स में। उदाहरण के लिए, getContext और getContexts जैसे कमांड्स वेबव्यू के बारे में विस्तृत जानकारी वापस कर सकते हैं, जिसमें शीर्षक, url और दृश्यता स्थिति शामिल है।

```ts
// Example: Retrieving detailed metadata for debugging
const contexts = await driver.getContexts({ returnDetailedContexts: true });
console.log(contexts);
```

यह मेटाडेटा समस्याओं की पहचान और समाधान में तेजी से मदद करता है, समग्र डीबगिंग अनुभव को बेहतर बनाता है।


मोबाइल कमांड्स को बेहतर बनाकर, WebdriverIO न केवल ऑटोमेशन को आसान बनाता है बल्कि अपने मिशन के साथ भी संरेखित होता है जिसमें डेवलपर्स को ऐसे टूल प्रदान किए जाते हैं जो शक्तिशाली, विश्वसनीय और उपयोग में आसान हैं।

---

## हाइब्रिड ऐप्स

हाइब्रिड ऐप्स वेब कंटेंट को नेटिव फंक्शनैलिटी के साथ जोड़ते हैं और ऑटोमेशन के दौरान विशेष हैंडलिंग की आवश्यकता होती है। ये ऐप्स नेटिव एप्लिकेशन के भीतर वेब कंटेंट रेंडर करने के लिए वेबव्यू का उपयोग करते हैं। WebdriverIO हाइब्रिड ऐप्स के साथ प्रभावी ढंग से काम करने के लिए उन्नत विधियां प्रदान करता है।

### वेबव्यू को समझना
वेबव्यू एक नेटिव ऐप में एम्बेडेड ब्राउज़र-जैसा कंपोनेंट है:

- **Android:** वेबव्यू Chrome/System Webview पर आधारित हैं और इनमें कई पेज (ब्राउज़र टैब के समान) हो सकते हैं। इन वेबव्यू को ऑटोमेट करने के लिए ChromeDriver की आवश्यकता होती है। Appium डिवाइस पर इंस्टॉल किए गए System WebView या Chrome के वर्जन के आधार पर आवश्यक ChromeDriver वर्जन को स्वचालित रूप से निर्धारित कर सकता है और यदि पहले से उपलब्ध नहीं है तो इसे स्वचालित रूप से डाउनलोड कर सकता है। यह दृष्टिकोण निर्बाध संगतता सुनिश्चित करता है और मैनुअल सेटअप को कम करता है। [Appium UIAutomator2-documentation](https://github.com/appium/appium-uiautomator2-driver?tab=readme-ov-file#automatic-discovery-of-compatible-chromedriver) देखें कि कैसे Appium स्वचालित रूप से सही ChromeDriver वर्जन डाउनलोड करता है।
- **iOS:** वेबव्यू Safari (WebKit) द्वारा संचालित होते हैं और `WEBVIEW_{id}` जैसे जेनेरिक आईडी से पहचाने जाते हैं।

### हाइब्रिड ऐप्स के साथ चुनौतियां
1. कई विकल्पों के बीच सही वेबव्यू की पहचान करना।
2. बेहतर संदर्भ के लिए शीर्षक, URL, या पैकेज नाम जैसे अतिरिक्त मेटाडेटा प्राप्त करना।
3. Android और iOS के बीच प्लेटफॉर्म-विशिष्ट अंतरों को संभालना।
4. हाइब्रिड ऐप में विश्वसनीय रूप से सही संदर्भ में स्विच करना।

### हाइब्रिड ऐप्स के लिए प्रमुख कमांड्स

#### 1. `getContext`
सेशन का वर्तमान संदर्भ प्राप्त करता है। डिफ़ॉल्ट रूप से, यह Appium के getContext विधि की तरह व्यवहार करता है लेकिन `returnDetailedContext` सक्षम होने पर विस्तृत संदर्भ जानकारी प्रदान कर सकता है। अधिक जानकारी के लिए [`getContext`](/docs/api/mobile/getContext) देखें

#### 2. `getContexts`
उपलब्ध संदर्भों की विस्तृत सूची लौटाता है, Appium के contexts विधि को बेहतर बनाता है। यह शीर्षक, url या सक्रिय `bundleId|packageName` निर्धारित करने के लिए अतिरिक्त कमांड्स को कॉल किए बिना इंटरैक्शन के लिए सही वेबव्यू की पहचान करना आसान बनाता है। अधिक जानकारी के लिए [`getContexts`](/docs/api/mobile/getContexts) देखें

#### 3. `switchContext`
नाम, शीर्षक, या url के आधार पर एक विशिष्ट वेबव्यू में स्विच करता है। मिलान के लिए रेगुलर एक्सप्रेशन का उपयोग करने जैसे अतिरिक्त लचीलापन प्रदान करता है। अधिक जानकारी के लिए [`switchContext`](/docs/api/mobile/switchContext) देखें

### हाइब्रिड ऐप्स के लिए प्रमुख विशेषताएं
1. विस्तृत मेटाडेटा: डीबगिंग और विश्वसनीय संदर्भ स्विचिंग के लिए व्यापक विवरण प्राप्त करें।
2. क्रॉस-प्लेटफॉर्म स्थिरता: Android और iOS के लिए एकीकृत व्यवहार, प्लेटफॉर्म-विशिष्ट क्विर्क्स को निर्बाध रूप से संभालना।
3. कस्टम रिट्राई लॉजिक (Android): वेबव्यू डिटेक्शन के लिए रिट्राई अंतराल और टाइमआउट समायोजित करना।


:::info नोट्स और सीमाएं
- Android अतिरिक्त मेटाडेटा जैसे `packageName` और `webviewPageId` प्रदान करता है, जबकि iOS `bundleId` पर केंद्रित है।
- रिट्राई लॉजिक Android के लिए अनुकूलन योग्य है लेकिन iOS के लिए लागू नहीं है।
- कई मामले हैं जिनमें iOS वेबव्यू नहीं ढूंढ सकता। Appium `appium-xcuitest-driver` के लिए वेबव्यू को खोजने के लिए विभिन्न अतिरिक्त क्षमताएं प्रदान करता है। यदि आपको लगता है कि वेबव्यू नहीं मिला है, तो आप निम्न में से एक क्षमता सेट करने का प्रयास कर सकते हैं:
    - `appium:includeSafariInWebviews`: नेटिव/वेबव्यू ऐप परीक्षण के दौरान उपलब्ध संदर्भों की सूची में Safari वेब संदर्भ जोड़ें। यह उपयोगी है यदि परीक्षण Safari खोलता है और इसके साथ इंटरैक्ट करने की आवश्यकता है। डिफ़ॉल्ट `false` है।
    - `appium:webviewConnectRetries`: वेब व्यू पेज डिटेक्शन पर हार मानने से पहले पुनः प्रयासों की अधिकतम संख्या। प्रत्येक पुनः प्रयास के बीच देरी 500ms है, डिफ़ॉल्ट `10` पुनः प्रयास है।
    - `appium:webviewConnectTimeout`: वेब व्यू पेज के पता लगाने की प्रतीक्षा करने के लिए मिलीसेकंड में अधिकतम समय। डिफ़ॉल्ट `5000` ms है।

उन्नत उदाहरणों और विवरण के लिए, WebdriverIO मोबाइल API दस्तावेज़ीकरण देखें।
:::


---

हमारे बढ़ते कमांड्स का सेट मोबाइल ऑटोमेशन को सुलभ और सुरुचिपूर्ण बनाने के हमारे प्रतिबद्धता को दर्शाता है। चाहे आप जटिल जेस्चर कर रहे हों या नेटिव ऐप एलिमेंट्स के साथ काम कर रहे हों, ये कमांड्स WebdriverIO के निर्बाध ऑटोमेशन अनुभव बनाने के दर्शन के साथ संरेखित हैं। और हम यहीं नहीं रुक रहे हैं—अगर कोई ऐसी सुविधा है जिसे आप देखना चाहते हैं, तो हम आपकी प्रतिक्रिया का स्वागत करते हैं। अपने अनुरोध [इस लिंक](https://github.com/webdriverio/webdriverio/issues/new/choose) के माध्यम से जमा करने के लिए स्वतंत्र महसूस करें।